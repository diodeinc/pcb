use std::env;
use std::fs;
use std::path::Path;

fn main() {
    let out_dir = env::var("OUT_DIR").unwrap();
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let pkg_version = env::var("CARGO_PKG_VERSION").unwrap();

    let changelog_path = Path::new(&manifest_dir).join("../../CHANGELOG.md");
    println!("cargo:rerun-if-changed={}", changelog_path.display());

    let changelog = fs::read_to_string(&changelog_path)
        .unwrap_or_else(|_| "# Changelog\n\nNo changelog available.".to_string());

    let (latest, is_unreleased) = extract_latest_release(&changelog);
    let latest = if is_unreleased {
        format!("## v{}\n{}", pkg_version, compact(&latest))
    } else {
        compact(&latest)
    };

    let output = format!(
        "// Auto-generated by build.rs\n\
         pub const CHANGELOG_MD: &str = {:?};\n\
         pub const LATEST_RELEASE_NOTES: &str = {:?};\n",
        compact_full(&changelog),
        latest
    );

    fs::write(Path::new(&out_dir).join("changelog.rs"), output)
        .expect("Failed to write changelog.rs");
}

/// Extract the first release section with actual content.
fn extract_latest_release(content: &str) -> (String, bool) {
    let mut result = Vec::new();
    let mut in_section = false;
    let mut has_content = false;
    let mut is_unreleased = false;

    for line in content.lines() {
        if line.starts_with("## [") {
            if in_section && has_content {
                break;
            }
            result.clear();
            in_section = true;
            has_content = false;
            is_unreleased = line.contains("[Unreleased]");
            if !is_unreleased {
                result.push(line);
            }
        } else if in_section {
            let trimmed = line.trim();
            if trimmed.starts_with("- ") || trimmed.starts_with("* ") {
                has_content = true;
            }
            if !trimmed.is_empty() || !result.is_empty() {
                result.push(line);
            }
        }
    }

    while result.last().is_some_and(|s| s.trim().is_empty()) {
        result.pop();
    }

    if result.is_empty() {
        ("No release notes available.".to_string(), false)
    } else {
        (result.join("\n"), is_unreleased)
    }
}

/// Compact a single release: remove blank lines, convert ### to **bold**.
fn compact(content: &str) -> String {
    content
        .lines()
        .filter(|line| !line.trim().is_empty())
        .map(|line| {
            line.trim()
                .strip_prefix("### ")
                .map(|h| format!("**{}**", h))
                .unwrap_or_else(|| line.to_string())
        })
        .collect::<Vec<_>>()
        .join("\n")
}

/// Compact full changelog: like compact(), but add blank lines between releases.
fn compact_full(content: &str) -> String {
    let mut result = Vec::new();
    let mut seen_release = false;
    let mut seen_links = false;

    for line in content.lines() {
        let trimmed = line.trim();
        if trimmed.is_empty() {
            continue;
        }

        // Blank line before each release header (except first)
        if trimmed.starts_with("## [") {
            if seen_release {
                result.push(String::new());
            }
            seen_release = true;
        }

        // Blank line before link references section
        if !seen_links && trimmed.starts_with('[') && trimmed.contains("]: http") {
            result.push(String::new());
            seen_links = true;
        }

        if let Some(header) = trimmed.strip_prefix("### ") {
            result.push(format!("**{}**", header));
        } else {
            result.push(line.to_string());
        }
    }

    result.join("\n")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_extract_unreleased_with_content() {
        let changelog = "## [Unreleased]\n### Added\n- Feature A\n## [0.3.22]\n- Old";
        let (result, is_unreleased) = extract_latest_release(changelog);
        assert!(is_unreleased);
        assert!(result.contains("Feature A"));
        assert!(!result.contains("Old"));
    }

    #[test]
    fn test_extract_versioned_when_unreleased_empty() {
        let changelog = "## [Unreleased]\n## [0.3.22]\n- Feature";
        let (result, is_unreleased) = extract_latest_release(changelog);
        assert!(!is_unreleased);
        assert!(result.contains("0.3.22"));
        assert!(result.contains("Feature"));
    }

    #[test]
    fn test_compact() {
        let input = "## [0.3.22]\n\n### Added\n\n- Feature";
        assert_eq!(compact(input), "## [0.3.22]\n**Added**\n- Feature");
    }
}
