use std::env;
use std::fs;
use std::path::Path;

fn main() {
    let out_dir = env::var("OUT_DIR").unwrap();
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let pkg_version = env::var("CARGO_PKG_VERSION").unwrap();

    // CHANGELOG.md is at workspace root (two levels up from crates/pcb/)
    let changelog_path = Path::new(&manifest_dir).join("../../CHANGELOG.md");
    println!("cargo:rerun-if-changed={}", changelog_path.display());

    let changelog_content = fs::read_to_string(&changelog_path)
        .unwrap_or_else(|_| "# Changelog\n\nNo changelog available.".to_string());

    // Parse the latest release section
    let (latest_release, is_unreleased) = extract_latest_release(&changelog_content);

    // Add version header for unreleased content and compact the output
    let latest_release = if is_unreleased {
        format!(
            "## v{}\n\n{}",
            pkg_version,
            compact_changelog(&latest_release)
        )
    } else {
        compact_changelog(&latest_release)
    };

    // Write the generated code
    let output = format!(
        r#"// Auto-generated by build.rs - do not edit

/// The full embedded changelog
pub const CHANGELOG_MD: &str = {:?};

/// The latest release notes (first non-empty release section)
pub const LATEST_RELEASE_NOTES: &str = {:?};
"#,
        changelog_content, latest_release
    );

    let dest_path = Path::new(&out_dir).join("changelog.rs");
    fs::write(dest_path, output).expect("Failed to write changelog.rs");
}

/// Extract the latest release section from the changelog.
/// If [Unreleased] has content, returns (content, true). Otherwise returns (first versioned release, false).
fn extract_latest_release(content: &str) -> (String, bool) {
    let lines: Vec<&str> = content.lines().collect();
    let mut result = Vec::new();
    let mut in_section = false;
    let mut found_content = false;
    let mut is_unreleased = false;

    for line in lines.iter() {
        // Check for section headers: ## [Unreleased] or ## [x.y.z]
        if line.starts_with("## [") {
            if in_section {
                // We've hit the next section, check if we found content
                if found_content {
                    break;
                }
                // Section was empty, try this one instead
                result.clear();
            }
            in_section = true;
            found_content = false;
            is_unreleased = line.contains("[Unreleased]");

            // Skip [Unreleased] header itself but include version headers
            if !is_unreleased {
                result.push(*line);
            }
        } else if in_section {
            // Check if this line has actual content (not just whitespace or subsection headers)
            let trimmed = line.trim();
            if !trimmed.is_empty()
                && !trimmed.starts_with("###")
                && (trimmed.starts_with("- ") || trimmed.starts_with("* "))
            {
                found_content = true;
            }
            // Include subsection headers and content
            if !trimmed.is_empty() || !result.is_empty() {
                result.push(*line);
            }
        }
    }

    // Trim trailing empty lines
    while result.last().map(|s| s.trim().is_empty()).unwrap_or(false) {
        result.pop();
    }

    if result.is_empty() {
        ("No release notes available.".to_string(), false)
    } else {
        (result.join("\n"), is_unreleased)
    }
}

/// Compact changelog by removing blank lines and making subsections inline
fn compact_changelog(content: &str) -> String {
    let mut result = Vec::new();

    for line in content.lines() {
        let trimmed = line.trim();

        // Skip empty lines entirely
        if trimmed.is_empty() {
            continue;
        }

        // Convert ### headers to **bold** inline style
        if let Some(header) = trimmed.strip_prefix("### ") {
            result.push(format!("**{}**", header));
        } else {
            result.push(line.to_string());
        }
    }

    result.join("\n")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_extract_unreleased_with_content() {
        let changelog = r#"# Changelog

## [Unreleased]

### Added

- New feature A
- New feature B

## [0.3.22] - 2026-01-13

### Added

- Old feature
"#;
        let (result, is_unreleased) = extract_latest_release(changelog);
        assert!(is_unreleased);
        assert!(result.contains("New feature A"));
        assert!(result.contains("New feature B"));
        assert!(!result.contains("Old feature"));
    }

    #[test]
    fn test_extract_versioned_when_unreleased_empty() {
        let changelog = r#"# Changelog

## [Unreleased]

## [0.3.22] - 2026-01-13

### Added

- Feature from 0.3.22

## [0.3.21] - 2026-01-10

### Added

- Old feature
"#;
        let (result, is_unreleased) = extract_latest_release(changelog);
        assert!(!is_unreleased);
        assert!(result.contains("0.3.22"));
        assert!(result.contains("Feature from 0.3.22"));
        assert!(!result.contains("Old feature"));
    }
}
