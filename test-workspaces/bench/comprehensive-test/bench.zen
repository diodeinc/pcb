ComprehensiveModule = Module("./module.zen")

# Advanced Sequential Matcher Library - The Complete Collection
def skip(n):
    def _matcher(path, cursor):
        if cursor + n > len(path.components):
            error("skip(" + str(n) + ") would consume past end of path")
        return n
    return _matcher

def skip_rest():
    def _matcher(path, cursor):
        return len(path.components) - cursor
    return _matcher

def is_resistor(expected_value=None):
    def _matcher(path, cursor):
        if cursor >= len(path.components):
            error("path ended, expected resistor")
        component = path.components[cursor]
        if component.type != "resistor":
            error(component.name + " is not a resistor (type: " + str(component.type) + ")")
        if expected_value != None:
            resistance_str = component.resistance.__str__(component.resistance)
            if resistance_str != expected_value:
                error(component.name + " value " + resistance_str + " != " + expected_value)
        return 1
    return _matcher

def is_capacitor(expected_value=None):
    def _matcher(path, cursor):
        if cursor >= len(path.components):
            error("path ended, expected capacitor")
        component = path.components[cursor]
        if component.type != "capacitor":
            error(component.name + " is not a capacitor (type: " + str(component.type) + ")")
        if expected_value != None:
            capacitance_str = component.capacitance.__str__(component.capacitance)
            if capacitance_str != expected_value:
                error(component.name + " value " + capacitance_str + " != " + expected_value)
        return 1
    return _matcher

def is_inductor():
    def _matcher(path, cursor):
        if cursor >= len(path.components):
            error("path ended, expected inductor")
        component = path.components[cursor]
        if component.type != "inductor":
            error(component.name + " is not an inductor (type: " + str(component.type) + ")")
        return 1
    return _matcher

def exactly_n_resistors(n):
    def _matcher(path, cursor):
        if cursor + n > len(path.components):
            error("exactly_n_resistors(" + str(n) + ") would consume past end of path")
        for i in range(n):
            component = path.components[cursor + i]
            if component.type != "resistor":
                error("Component " + str(i + 1) + "/" + str(n) + " (" + component.name + ") is not a resistor")
        return n
    return _matcher

def exactly_n_capacitors(n):
    def _matcher(path, cursor):
        if cursor + n > len(path.components):
            error("exactly_n_capacitors(" + str(n) + ") would consume past end of path")
        for i in range(n):
            component = path.components[cursor + i]
            if component.type != "capacitor":
                error("Component " + str(i + 1) + "/" + str(n) + " (" + component.name + ") is not a capacitor")
        return n
    return _matcher

def has_package(expected_package):
    def _matcher(path, cursor):
        if cursor >= len(path.components):
            error("path ended, expected component")
        component = path.components[cursor]
        if not hasattr(component, "properties") or "Package" not in component.properties:
            error(component.name + " missing Package property")
        actual = component.properties["Package"]
        if actual != expected_package:
            error(component.name + " package " + actual + " != " + expected_package)
        return 1
    return _matcher

def name_contains(pattern):
    def _matcher(path, cursor):
        if cursor >= len(path.components):
            error("path ended, expected component")
        component = path.components[cursor]
        if pattern not in component.name:
            error(component.name + " does not contain '" + pattern + "'")
        return 1
    return _matcher

def alternating_rc():
    """Match exactly R then C pattern"""
    def _matcher(path, cursor):
        if cursor + 2 > len(path.components):
            error("alternating_rc() needs 2 components")
        if path.components[cursor].type != "resistor":
            error("First component should be resistor")
        if path.components[cursor + 1].type != "capacitor":
            error("Second component should be capacitor")
        return 2
    return _matcher

def test_simple_paths(module):
    """Test basic single-component paths"""
    print("Testing Simple Paths:")
    graph = module.graph()
    nets = module.nets()
    
    # Test direct VCC-to-GND paths (decoupling caps)
    paths = graph.paths(start="VCC_VCC", end="GND_GND", max_depth=3)
    print("  Found " + str(len(paths)) + " direct VCC-to-GND paths")
    
    single_component_paths = [p for p in paths if len(p.components) == 1]
    print("  Found " + str(len(single_component_paths)) + " single-component paths")
    
    for i, path in enumerate(single_component_paths):
        component = path.components[0]
        print("  Path " + str(i + 1) + ": " + component.name + " (" + str(component.type) + ")")
        
        # Test each capacitor path individually
        if component.type == "capacitor":
            if "C2" in component.name:
                print("    Testing 10uF bulk capacitor...")
                path.matches(is_capacitor("10uF"))
                path.matches(has_package("0805"))
                print("      ✓ 10uF/0805 bulk capacitor validated")
                
            elif "C3" in component.name:
                print("    Testing 1uF medium capacitor...")  
                path.matches(is_capacitor("1uF"))
                path.matches(has_package("0603"))
                print("      ✓ 1uF/0603 medium capacitor validated")

def test_multi_component_paths(module):
    """Test paths with multiple components"""
    print("Testing Multi-Component Paths:")
    graph = module.graph()
    
    # Find all multi-component paths
    paths = graph.paths(start="VCC_VCC", end="GND_GND", max_depth=10)
    multi_paths = [p for p in paths if len(p.components) > 1]
    print("  Found " + str(len(multi_paths)) + " multi-component paths")
    
    for i, path in enumerate(multi_paths):
        comp_names = [c.name + "(" + str(c.type) + ")" for c in path.components]
        print("  Path " + str(i + 1) + ": " + str(comp_names))
        
        # Test different patterns based on path length and components
        if len(path.components) == 2:
            # Should be RC filter or voltage divider
            if path.components[0].type == "resistor" and path.components[1].type == "capacitor":
                print("    Testing RC filter pattern...")
                path.matches(
                    is_resistor(),   # R1
                    is_capacitor()   # C1  
                )
                print("      ✓ RC filter pattern validated")
                
            elif path.components[0].type == "resistor" and path.components[1].type == "resistor":
                print("    Testing voltage divider pattern...")
                path.matches(
                    is_resistor(),   # R4 or R5
                    is_resistor()    # R5 or R4
                )
                print("      ✓ Voltage divider pattern validated")
                
        elif len(path.components) == 4:
            # Should be the complex filter: R2 -> L1 -> R3 -> C4
            print("    Testing complex filter chain...")
            path.matches(
                is_resistor("100"),   # R2 input resistor
                is_inductor(),        # L1 filter inductor
                is_resistor("10k"),   # R3 series resistor  
                is_capacitor("470nF") # C4 filter cap
            )
            print("      ✓ Complex R-L-R-C filter chain validated")

def test_advanced_sequential_patterns(module):
    """Test advanced sequential matching capabilities"""
    print("Testing Advanced Sequential Patterns:")
    graph = module.graph()
    
    # Find the 4-component filter path
    paths = graph.paths(start="VCC_VCC", end="GND_GND", max_depth=10)
    filter_path = None
    
    for path in paths:
        if len(path.components) == 4:
            # Check if it has the expected R-L-R-C pattern
            types = [c.type for c in path.components]
            if types == ["resistor", "inductor", "resistor", "capacitor"]:
                filter_path = path
                break
    
    if filter_path:
        print("  Found 4-component filter path for advanced testing")
        
        # Test 1: Skip patterns
        print("  Test: Advanced skip patterns...")
        filter_path.matches(
            skip(2),          # Skip R2 and L1
            is_resistor(),    # Match R3
            is_capacitor()    # Match C4
        )
        print("    ✓ Skip(2) + specific component matching works")
        
        # Test 2: Exact counting
        print("  Test: Exact component counting...")
        filter_path.matches(
            exactly_n_resistors(1),  # First resistor (R2)
            skip(1),                 # Skip inductor
            exactly_n_resistors(1),  # Second resistor (R3)
            exactly_n_capacitors(1)  # Final capacitor
        )
        print("    ✓ Exact component counting works")
        
        # Test 3: Package size validation
        print("  Test: Package size validation...")
        filter_path.matches(
            has_package("0603"),     # R2 package
            has_package("0805"),     # L1 package  
            has_package("0603"),     # R3 package
            has_package("0603")      # C4 package
        )
        print("    ✓ Package size validation works")
        
        # Test 4: Name pattern matching
        print("  Test: Name pattern matching...")
        filter_path.matches(
            name_contains("R2"),     # R2
            name_contains("L1"),     # L1
            name_contains("R3"),     # R3
            name_contains("C4")      # C4
        )
        print("    ✓ Name pattern matching works")

def test_path_analysis(module):
    """Analyze all paths and demonstrate various matching strategies"""
    print("Testing Path Analysis:")
    graph = module.graph()
    
    paths = graph.paths(start="VCC_VCC", end="GND_GND", max_depth=10)
    print("  Total paths found: " + str(len(paths)))
    
    # Categorize paths by length
    path_categories = {}
    for path in paths:
        length = len(path.components)
        if length not in path_categories:
            path_categories[length] = []
        path_categories[length].append(path)
    
    for length, path_list in path_categories.items():
        print("  " + str(length) + "-component paths: " + str(len(path_list)))
        
        # Test each category with appropriate patterns
        if length == 1:
            print("    Testing single-component paths...")
            for path in path_list:
                # All should be capacitors (decoupling)
                path.matches(is_capacitor())
            print("      ✓ All single-component paths are capacitors")
            
        elif length == 2:
            print("    Testing two-component paths...")  
            for path in path_list:
                # Should be either RC or RR patterns
                first_type = path.components[0].type
                second_type = path.components[1].type
                if first_type == "resistor" and second_type == "capacitor":
                    path.matches(alternating_rc())
                elif first_type == "resistor" and second_type == "resistor":
                    path.matches(exactly_n_resistors(2))
                print("      ✓ Two-component pattern validated")
                break  # Just test one of each type
            
        elif length == 4:
            print("    Testing four-component filter path...")
            path = path_list[0]  # Should be our R-L-R-C filter
            path.matches(
                is_resistor("100"),   # R2
                is_inductor(),        # L1 
                is_resistor("10k"),   # R3
                is_capacitor("470nF") # C4
            )
            print("      ✓ Four-component filter chain validated")

def test_expected_failures(module):
    """Document expected failure cases (commented out to avoid breaking the build)"""
    print("Testing Expected Failures (Documented):")
    graph = module.graph()
    paths = graph.paths(start="VCC_VCC", end="GND_GND", max_depth=10)
    
    if paths:
        simple_path = [p for p in paths if len(p.components) == 1][0]  # Single cap path
        complex_path = [p for p in paths if len(p.components) == 4][0]  # Filter path
        
        print("  Expected Failures for Single-Component Path:")
        print("    # simple_path.matches(is_resistor())")
        print("    Expected: 'C2.C is not a resistor (type: capacitor)'")
        print()
        print("    # simple_path.matches(is_capacitor('999F'))")
        print("    Expected: 'C2.C value 10uF != 999F'")
        print()
        print("    # simple_path.matches(skip(5))")
        print("    Expected: 'skip(5) would consume past end of path'")
        print()
        
        print("  Expected Failures for Complex Filter Path:")
        print("    # complex_path.matches(is_capacitor(), skip_rest())")
        print("    Expected: 'R2.R is not a capacitor (type: resistor)'")
        print()
        print("    # complex_path.matches(is_resistor(), is_resistor(), is_resistor())")
        print("    Expected: 'L1.L is not a resistor (type: inductor)'")
        print()
        print("    # complex_path.matches(is_resistor('999kOhm'), skip_rest())")
        print("    Expected: 'R2.R value 100 != 999kOhm'")
        print()
        print("    # complex_path.matches(is_resistor())")  # Under-consumption
        print("    Expected: 'Unconsumed components remaining (3 left)'")
        print()
        print("    # complex_path.matches(has_package('2512'), skip_rest())")
        print("    Expected: 'R2.R package 0603 != 2512'")

def test_package_size_patterns(module):
    """Test package size consistency across circuit"""
    print("Testing Package Size Patterns:")
    graph = module.graph()
    
    # Find all paths and validate package assignments
    paths = graph.paths(start="VCC_VCC", end="GND_GND", max_depth=10)
    
    print("  Validating package size assignments...")
    package_violations = []
    
    for path in paths:
        for component in path.components:
            if hasattr(component, "properties") and "Package" in component.properties:
                pkg = component.properties["Package"]
                
                # Validate typical package size rules
                if component.type == "capacitor":
                    cap_str = component.capacitance.__str__(component.capacitance)
                    expected_large = "0805" if "10uF" in cap_str else None
                    expected_small = "0402" if "100nF" in cap_str else None
                    
                    if expected_large and pkg != expected_large:
                        package_violations.append(component.name + ": " + cap_str + " should use " + expected_large)
                    elif expected_small and pkg != expected_small:
                        package_violations.append(component.name + ": " + cap_str + " should use " + expected_small)
                        
                elif component.type == "resistor":
                    # Precision resistors (≥10kΩ) should use smaller packages
                    res_str = component.resistance.__str__(component.resistance)
                    if "2.2k" in res_str and pkg != "0402":
                        package_violations.append(component.name + ": precision resistor should use 0402")
    
    if not package_violations:
        print("    ✓ All package sizes are appropriate for their values")
    else:
        for violation in package_violations:
            print("    ! " + violation)

TestBench(
    name="ComprehensiveTest",
    module=ComprehensiveModule,
    checks=[
        test_simple_paths,
        test_multi_component_paths,
        test_advanced_sequential_patterns,
        test_path_analysis,
        test_package_size_patterns,
        test_expected_failures,
    ],
)
