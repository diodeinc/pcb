Foo = Module("./module.zen")

def print_info(module: Module):
    nets = module.nets()
    components = module.components()
    print("Nets and their connected ports:")
    for (net_name, port_list) in nets.items():
        print(f"  {net_name}: {port_list}")
    print("Components and their attributes:")
    for (comp_name, comp) in components.items():
        print(f"  {comp_name}:")
        print("    Name:", comp.name)
        print("    Prefix:", comp.prefix)
        if comp.mpn:
            print("    MPN:", comp.mpn)
        if comp.type:
            print("    Type:", comp.type)
        if comp.type == "capacitor":
            print("    Capacitance:", comp.capacitance.__str__(comp.capacitance))
        elif comp.type == "resistor":
            print("    Resistance:", comp.resistance.__str__(comp.resistance))
        print("    Properties:", comp.properties)
        pins = {}
        for (pin, net) in comp.pins.items():
            pins[pin] = net.name
        print("    Pins:", pins)

def ensure_gnd(module):
    nets = module.nets()
    for net_name in nets.keys():
        if "GND" in net_name:
            return
    error("GND net not found")

def check_power_connections(module):
    """Check that VCC nets have at least 2 connections total (components properly powered)"""
    nets = module.nets()
    for (net_name, port_list) in nets.items():
        if "VCC" in net_name:
            check(len(port_list) >= 2, "VCC net must have at least 2 connections")

def check_resistor_grounding(module):
    """Check that resistor R.P2 is connected to ground using ports dict"""
    components = module.components()
    connected_net = components["R.R"].pins["P2"].name
    check("GND" in connected_net, "Resistor P2 is connected to " + connected_net + ", not ground!")

def check_resistor_values(module):
    """Check that resistors have valid values using components dict"""
    components = module.components()
    for (comp_name, comp) in components.items():
        if comp.type == "resistor":
            resistance = comp.resistance
            print("âœ“ " + comp_name + " has resistance: " + resistance.__str__(resistance))

def print_graph_info(module: Module):
    print("Circuit Graph Information:")
    graph = module.graph()
    print("  Graph object:", graph)
    print("  Graph type:", type(graph))

def explore_paths(module: Module):
    """Demonstrate pathfinding between different points in the circuit"""
    print("Path Analysis:")
    graph = module.graph()
    
    # Try to find paths between different nets (use public nets for pathfinding)
    nets = module.nets()
    net_names = list(nets.keys())
    
    # Use public nets for pathfinding (VCC_VCC and GND_GND are from io() parameters)
    public_nets = [name for name in net_names if name in ["VCC_VCC", "GND_GND"]]
    
    if len(public_nets) >= 2:
        start_net = public_nets[0]  
        end_net = public_nets[1]
        print("  Looking for paths from '" + start_net + "' to '" + end_net + "'...")
        
        # Note: Error handling simplified for Starlark compatibility
        paths = graph.paths(start=start_net, end=end_net, max_depth=5)
        print("  Found " + str(len(paths)) + " paths")
        
        for i, path in enumerate(paths):
            print("    Path " + str(i+1) + ":")
            print("      Ports: " + str(path.ports))
            print("      Components: " + str(len(path.components)) + " components")
            print("      Nets: " + str(path.nets))
    
    # Try pathfinding using component port tuples
    components = module.components()
    if len(components) >= 2:
        comp_names = list(components.keys())
        comp1 = comp_names[0]
        comp2 = comp_names[1] if len(comp_names) > 1 else comp_names[0]
        
        # Get first pin of each component  
        comp1_pins = list(components[comp1].pins.keys())
        comp2_pins = list(components[comp2].pins.keys())
        
        if comp1_pins and comp2_pins:
            start_port = (comp1, comp1_pins[0])
            end_port = (comp2, comp2_pins[0])
            print("  Looking for paths from " + str(start_port) + " to " + str(end_port) + "...")
            
            paths = graph.paths(start=start_port, end=end_port, max_depth=8)
            print("  Found " + str(len(paths)) + " component-to-component paths")
            
            if paths:
                # Show details of first path and demonstrate validation methods
                path = paths[0]
                print("    First path details:")
                print("      Path length: " + str(len(path.ports)) + " ports")
                print("      Component count: " + str(len(path.components)) + " components")
                
                # TODO: Add component matcher examples when matchers are implemented
                # print(f"      Resistor count: {path.count(is_resistor())}")
                # print(f"      Has capacitors: {path.any(is_capacitor())}")

TestBench(
    name="FOO",
    module=Foo,
    checks=[
        print_info,
        print_graph_info,
        explore_paths,
        ensure_gnd,
        check_resistor_grounding,
        check_resistor_values,
        check_power_connections,
    ],
)
