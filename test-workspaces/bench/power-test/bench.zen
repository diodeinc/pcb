PowerModule = Module("./module.zen")

# Comprehensive matcher library with advanced pattern matching
def skip(n):
    def _matcher(path, cursor):
        if cursor + n > len(path.components):
            error("skip(" + str(n) + ") would consume past end of path")
        return n
    return _matcher

def skip_rest():
    def _matcher(path, cursor):
        return len(path.components) - cursor
    return _matcher

def is_resistor(expected_value=None):
    def _matcher(path, cursor):
        if cursor >= len(path.components):
            error("path ended, expected resistor")
        component = path.components[cursor]
        if component.type != "resistor":
            error(component.name + " is not a resistor (type: " + str(component.type) + ")")
        if expected_value != None:
            resistance_str = component.resistance.__str__(component.resistance)
            if resistance_str != expected_value:
                error(component.name + " value " + resistance_str + " != " + expected_value)
        return 1
    return _matcher

def is_capacitor(expected_value=None):
    def _matcher(path, cursor):
        if cursor >= len(path.components):
            error("path ended, expected capacitor")
        component = path.components[cursor]
        if component.type != "capacitor":
            error(component.name + " is not a capacitor (type: " + str(component.type) + ")")
        if expected_value != None:
            capacitance_str = component.capacitance.__str__(component.capacitance)
            if capacitance_str != expected_value:
                error(component.name + " value " + capacitance_str + " != " + expected_value)
        return 1
    return _matcher

def is_inductor(expected_value=None):
    def _matcher(path, cursor):
        if cursor >= len(path.components):
            error("path ended, expected inductor")
        component = path.components[cursor]
        if component.type != "inductor":
            error(component.name + " is not an inductor (type: " + str(component.type) + ")")
        return 1
    return _matcher

def exactly_n_of_type(n, component_type):
    """Exactly n consecutive components of specified type"""
    def _matcher(path, cursor):
        if cursor + n > len(path.components):
            error("exactly_n_of_type(" + str(n) + ") would consume past end of path")
        for i in range(n):
            component = path.components[cursor + i]
            if component.type != component_type:
                error("Component " + str(i + 1) + "/" + str(n) + " (" + component.name + ") is not " + component_type)
        return n
    return _matcher

def has_package_size(expected_package):
    """Match component with specific package size"""
    def _matcher(path, cursor):
        if cursor >= len(path.components):
            error("path ended, expected component")
        component = path.components[cursor]
        if not hasattr(component, "properties") or "Package" not in component.properties:
            error(component.name + " missing Package property")
        actual_package = component.properties["Package"]
        if actual_package != expected_package:
            error(component.name + " package " + actual_package + " != " + expected_package)
        return 1
    return _matcher

def value_greater_than(threshold_str):
    """Match component with value greater than threshold (simplified)"""
    def _matcher(path, cursor):
        if cursor >= len(path.components):
            error("path ended, expected component")
        component = path.components[cursor]
        # For demo purposes, just check it has a reasonable value
        if component.type == "resistor":
            resistance_str = component.resistance.__str__(component.resistance)
            # Simplified check - just verify it's not empty
            if not resistance_str:
                error(component.name + " has no resistance value")
        elif component.type == "capacitor":
            capacitance_str = component.capacitance.__str__(component.capacitance)
            if not capacitance_str:
                error(component.name + " has no capacitance value")
        return 1
    return _matcher

def alternates_between(type1, type2):
    """Match alternating pattern of two component types"""
    def _matcher(path, cursor):
        if cursor + 1 >= len(path.components):
            error("alternates_between needs at least 2 components")
        comp1 = path.components[cursor]
        comp2 = path.components[cursor + 1]
        if comp1.type != type1:
            error("Component 1 (" + comp1.name + ") is not " + type1)
        if comp2.type != type2:
            error("Component 2 (" + comp2.name + ") is not " + type2)
        return 2
    return _matcher

def name_starts_with(prefix):
    """Match component whose name starts with prefix"""
    def _matcher(path, cursor):
        if cursor >= len(path.components):
            error("path ended, expected component")
        component = path.components[cursor]
        if not component.name.startswith(prefix):
            error(component.name + " does not start with " + prefix)
        return 1
    return _matcher

def test_input_filtering_stage(module):
    """Test input power filtering stage"""
    print("Testing Input Power Filtering:")
    
    # Debug nets first
    nets = module.nets()
    print("  Available nets:", list(nets.keys()))
    
    graph = module.graph()
    
    # Find all VIN to GND paths (should include input caps)  
    paths = graph.paths(start="VIN_VIN", end="GND_GND", max_depth=5)
    print("  Found " + str(len(paths)) + " VIN-to-GND paths")
    
    # Should find both input capacitors
    bulk_cap_found = False
    bypass_cap_found = False
    
    for i, path in enumerate(paths):
        print("  Path " + str(i + 1) + ": " + str([c.name + "(" + str(c.type) + ")" for c in path.components]))
        
        # Test each path - should be single capacitor paths
        if len(path.components) == 1:
            comp = path.components[0]
            if comp.name == "C_IN1":
                print("    Testing bulk input capacitor...")
                path.matches(
                    is_capacitor("10uF")
                )
                print("      ✓ 10uF bulk capacitor validated")
                bulk_cap_found = True
            elif comp.name == "C_IN2":  
                print("    Testing bypass capacitor...")
                path.matches(
                    is_capacitor("100nF")
                )
                print("      ✓ 100nF bypass capacitor validated")
                bypass_cap_found = True
    
    if bulk_cap_found and bypass_cap_found:
        print("    ✓ Complete input filtering stage validated")

def test_output_filtering_stage(module):
    """Test output power filtering with inductor"""
    print("Testing Output Power Filtering:")
    graph = module.graph()
    
    # Find VOUT to GND paths (should include output caps)
    paths = graph.paths(start="VOUT_VOUT", end="GND_GND", max_depth=5)
    print("  Found " + str(len(paths)) + " VOUT-to-GND paths")
    
    for i, path in enumerate(paths):
        comp_names = [c.name for c in path.components]
        print("  Path " + str(i + 1) + ": " + str([c.name + "(" + str(c.type) + ")" for c in path.components]))
        
        # Test output capacitor paths
        if len(path.components) == 1 and path.components[0].type == "capacitor":
            if "OUT1" in path.components[0].name:
                print("    Testing main output capacitor...")
                path.matches(
                    is_capacitor("22uF")
                )
                print("      ✓ 22uF main output capacitor validated")
            elif "OUT2" in path.components[0].name:
                print("    Testing output bypass capacitor...")
                path.matches(
                    is_capacitor("100nF")
                )
                print("      ✓ 100nF output bypass validated")

def test_feedback_divider_chain(module):
    """Test feedback voltage divider"""
    print("Testing Feedback Divider:")
    graph = module.graph()
    
    # Find VOUT to GND via feedback network  
    paths = graph.paths(start="VOUT_VOUT", end="GND_GND", max_depth=10)
    
    # Look for the 2-resistor feedback path
    feedback_path = None
    for path in paths:
        if len(path.components) == 2:
            # Check if both components are resistors
            all_resistors = True
            for c in path.components:
                if c.type != "resistor":
                    all_resistors = False
                    break
        if len(path.components) == 2 and all_resistors:
            comp_names = [c.name for c in path.components]
            if "FB1" in comp_names[0] and "FB2" in comp_names[1]:
                feedback_path = path
                break
    
    if feedback_path:
        print("  Found feedback divider path: " + str([c.name for c in feedback_path.components]))
        print("  Testing voltage divider ratios...")
        feedback_path.matches(
            is_resistor("21.5k"),  # Upper resistor
            is_resistor("10k")     # Lower resistor  
        )
        print("    ✓ Feedback voltage divider validated (VOUT = 0.8V * (1 + 21.5k/10k) = 2.52V)")
    else:
        print("  No feedback divider path found")

def test_component_package_consistency(module):
    """Test component package assignments"""
    print("Testing Component Packages:")
    graph = module.graph()
    
    # Test various paths and check package consistency
    paths = graph.paths(start="VIN_VIN", end="GND_GND", max_depth=5)
    
    package_violations = []
    for path in paths:
        for component in path.components:
            if component.type == "capacitor":
                cap_value_str = component.capacitance.__str__(component.capacitance)
                expected_pkg = None
                
                # Check package size rules
                if "10uF" in cap_value_str or "22uF" in cap_value_str:
                    expected_pkg = "0805" if "10uF" in cap_value_str else "1206"
                elif "100nF" in cap_value_str or "10nF" in cap_value_str:
                    expected_pkg = "0402"
                
                if expected_pkg and hasattr(component, "properties"):
                    actual_pkg = component.properties.get("Package", "unknown")
                    if actual_pkg != expected_pkg:
                        package_violations.append(
                            component.name + ": " + cap_value_str + " should be " + expected_pkg + ", got " + actual_pkg
                        )
    
    if package_violations:
        print("  Package violations found:")
        for violation in package_violations:
            print("    " + violation)
    else:
        print("    ✓ All component packages correctly sized")

def test_complex_patterns(module):
    """Test complex component patterns and sequences"""
    print("Testing Complex Patterns:")
    graph = module.graph()
    
    # Find longer paths that traverse multiple components
    paths = graph.paths(start="VIN_VIN", end="VOUT_VOUT", max_depth=15)
    print("  Found " + str(len(paths)) + " VIN-to-VOUT power paths")
    
    # Look for a path through the power conversion chain
    for i, path in enumerate(paths):
        if len(path.components) >= 3:  # Multi-stage path
            print("  Complex path " + str(i + 1) + ": " + str([c.name + "(" + str(c.type) + ")" for c in path.components]))
            
            # This should be a path through the inductor and possibly other components
            # Check if path has inductor
            has_inductor = False
            for c in path.components:
                if c.type == "inductor":
                    has_inductor = True
                    break
            if has_inductor:
                print("    Testing power conversion path with inductor...")
                # Find the inductor position
                # Find inductor position
                inductor_pos = -1
                for i, c in enumerate(path.components):
                    if c.type == "inductor":
                        inductor_pos = i
                        break
                print("    Inductor found at position " + str(inductor_pos))
                
                # Test that we have the right inductor
                inductor_component = path.components[inductor_pos]
                if inductor_component.name == "L_OUT":
                    print("      ✓ Found L_OUT output inductor in power path")
                break

# Expected failure test cases (commented out to avoid actual failures)
def test_expected_failures(module):
    """Tests that should fail - demonstrating comprehensive error conditions"""
    print("Testing Expected Failure Cases:")
    graph = module.graph()
    paths = graph.paths(start="VIN_VIN", end="GND_GND", max_depth=5)
    
    if paths:
        path = paths[0]  # Use first path
        
        print("  Expected failures (commented out):")
        print("    1. Wrong component type:")
        print("       # path.matches(is_inductor())  # First component is capacitor")
        print("       Expected: 'C_IN1.C is not an inductor'")
        
        print("    2. Wrong component value:")  
        print("       # path.matches(is_capacitor('1F'))  # Way too big")
        print("       Expected: 'C_IN1.C value 10uF != 1F'")
        
        print("    3. Package size mismatch:")
        print("       # path.matches(has_package_size('2512'))  # Wrong package")
        print("       Expected: 'C_IN1.C package 0805 != 2512'")
        
        print("    4. Sequence length mismatch:")
        print("       # path.matches(exactly_n_of_type(5, 'capacitor'))  # Only 1 in path")
        print("       Expected: 'exactly_n_of_type(5) would consume past end of path'")
        
        print("    5. Name pattern mismatch:")
        print("       # path.matches(name_starts_with('R_'))  # Component starts with 'C_'")
        print("       Expected: 'C_IN1.C does not start with R_'")

TestBench(
    name="PowerSupply",
    module=PowerModule, 
    checks=[
        test_input_filtering_stage,
        test_output_filtering_stage,
        test_feedback_divider_chain,
        test_component_package_consistency,
        test_complex_patterns,
        test_expected_failures,
    ],
)
