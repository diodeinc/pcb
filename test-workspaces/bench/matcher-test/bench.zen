TestModule = Module("./module.zen")

# Reuse the comprehensive matcher library instead of reimplementing
load("../simple-matchers.zen", "skip", "skip_rest", "is_resistor", "is_capacitor", "debug_print_path")

def test_sequential_matching(module):
    """Test the new sequential matching functionality"""
    print("Testing Sequential Matchers:")
    
    # Debug nets first
    nets = module.nets()
    print("  Available nets:", list(nets.keys()))
    for net_name, ports in nets.items():
        print("    " + net_name + ": " + str(ports))
    
    graph = module.graph()
    
    # Find paths from VCC to GND
    paths = graph.paths(start="VCC_VCC", end="GND_GND", max_depth=10)
    print("  Found " + str(len(paths)) + " VCC-to-GND paths")
    
    if paths:
        path = paths[0]
        print("  Path components: " + str([c.name + "(" + str(c.type) + ")" for c in path.components]))
        
        # Test 1: Simple sequential matching - expect R, C, R, R
        print("  Test 1: Sequential R-C-R-R pattern...")
        path.matches(
            is_resistor(),    # R1 (1k)  
            is_capacitor(),   # C1 (100nF)
            is_resistor(),    # R2 (10k)
            is_resistor()     # R3 (100k)
        )
        print("    ✓ Sequential R-C-R-R pattern matched successfully")
        
        # Test 2: Test skip() functionality
        print("  Test 2: Skip functionality...")
        path.matches(
            skip(1),          # Skip R1
            is_capacitor(),   # Match C1
            skip(2)           # Skip R2, R3
        )
        print("    ✓ Skip functionality works")

def test_advanced_matchers(module):
    """Test advanced matcher functionality"""
    print("Testing Advanced Matchers:")
    graph = module.graph()
    paths = graph.paths(start="VCC_VCC", end="GND_GND", max_depth=10)
    
    if paths:
        path = paths[0]
        debug_print_path(path)
        
        # Test: skip_rest should consume entire path
        print("  Test: skip_rest functionality...")
        path.matches(
            skip_rest()  # Should consume all 4 components
        )
        print("    ✓ skip_rest works")
        
        # Test: specific value matching
        print("  Test: specific value matching...")
        path.matches(
            is_resistor("1k"),      # R1 should be 1k
            is_capacitor("100nF"),  # C1 should be 100nF
            is_resistor("10k"),     # R2 should be 10k
            is_resistor("100k")     # R3 should be 100k
        )
        print("    ✓ specific value matching works")

# Removed error test cases to avoid try/except syntax issues

TestBench(
    name="SequentialMatchers",
    module=TestModule,
    checks=[
        test_sequential_matching,
        test_advanced_matchers,
    ],
)
