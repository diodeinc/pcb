FilterModule = Module("./module.zen")

# Advanced matcher library
def skip(n):
    def _matcher(path, cursor):
        if cursor + n > len(path.components):
            error("skip(" + str(n) + ") would consume past end of path")
        return n
    return _matcher

def is_resistor(expected_value=None):
    def _matcher(path, cursor):
        if cursor >= len(path.components):
            error("path ended, expected resistor")
        component = path.components[cursor]
        if component.type != "resistor":
            error(component.name + " is not a resistor (type: " + str(component.type) + ")")
        if expected_value != None:
            resistance_str = component.resistance.__str__(component.resistance)
            if resistance_str != expected_value:
                error(component.name + " value " + resistance_str + " != " + expected_value)
        return 1
    return _matcher

def is_capacitor(expected_value=None):
    def _matcher(path, cursor):
        if cursor >= len(path.components):
            error("path ended, expected capacitor")
        component = path.components[cursor]
        if component.type != "capacitor":
            error(component.name + " is not a capacitor (type: " + str(component.type) + ")")
        if expected_value != None:
            capacitance_str = component.capacitance.__str__(component.capacitance)
            if capacitance_str != expected_value:
                error(component.name + " value " + capacitance_str + " != " + expected_value)
        return 1
    return _matcher

def is_inductor(expected_value=None):
    def _matcher(path, cursor):
        if cursor >= len(path.components):
            error("path ended, expected inductor")
        component = path.components[cursor]
        if component.type != "inductor":
            error(component.name + " is not an inductor (type: " + str(component.type) + ")")
        return 1
    return _matcher

def skip_rest():
    def _matcher(path, cursor):
        return len(path.components) - cursor
    return _matcher

def is_component_type(component_type):
    def _matcher(path, cursor):
        if cursor >= len(path.components):
            error("path ended, expected " + component_type)
        component = path.components[cursor]
        if component.type != component_type:
            error(component.name + " is not a " + component_type + " (type: " + str(component.type) + ")")
        return 1
    return _matcher

def exactly(n, matcher):
    """Exactly n consecutive components must match"""
    def _matcher(path, cursor):
        if cursor + n > len(path.components):
            error("exactly(" + str(n) + ") would consume past end of path")
        for i in range(n):
            # Simple check without safe call for now
            component = path.components[cursor + i]
            # We'll call the inner matcher function directly
            if matcher == is_resistor():
                if component.type != "resistor":
                    error("exactly() failed: component " + str(i + 1) + " is not a resistor")
            elif matcher == is_capacitor():
                if component.type != "capacitor":
                    error("exactly() failed: component " + str(i + 1) + " is not a capacitor")
        return n
    return _matcher

def has_property(prop_name, expected_value=None):
    def _matcher(path, cursor):
        if cursor >= len(path.components):
            error("path ended, expected component with property")
        component = path.components[cursor]
        if not hasattr(component, "properties") or prop_name not in component.properties:
            error(component.name + " missing property: " + prop_name)
        if expected_value != None and component.properties[prop_name] != expected_value:
            actual = component.properties[prop_name]
            error(component.name + " property " + prop_name + " = " + str(actual) + " != " + str(expected_value))
        return 1
    return _matcher

def name_contains(pattern):
    def _matcher(path, cursor):
        if cursor >= len(path.components):
            error("path ended, expected component")
        component = path.components[cursor]
        if pattern not in component.name:
            error(component.name + " does not contain pattern: " + pattern)
        return 1
    return _matcher

def test_filter_signal_path(module):
    """Test signal path through filter circuit"""
    print("Testing Filter Signal Path:")
    
    # Debug nets first
    nets = module.nets()
    print("  Available nets:", list(nets.keys()))
    
    graph = module.graph()
    
    # Test INPUT to OUTPUT signal path  
    paths = graph.paths(start="INPUT_NET", end="OUTPUT_NET", max_depth=15)
    print("  Found " + str(len(paths)) + " INPUT-to-OUTPUT signal paths")
    
    if paths:
        path = paths[0]
        print("  Path components: " + str([c.name + "(" + str(c.type) + ")" for c in path.components]))
        
        # Test complete filter chain pattern: R-C-R-L-R-C
        print("  Test: Complete filter chain pattern...")
        path.matches(
            is_resistor(),    # R1 - input resistor
            is_capacitor(),   # C1 - AC coupling
            is_resistor(),    # R2 - filter input
            is_inductor(),    # L1 - filter element
            is_resistor(),    # R3 - output resistor 
            is_capacitor()    # C3 - DC blocking
        )
        print("    ✓ Complete R-C-R-L-R-C filter chain validated")
        
        # Test with specific values
        print("  Test: Filter with specific component values...")
        path.matches(
            is_resistor("1k"),      # R1 input
            is_capacitor("1uF"),    # C1 coupling
            is_resistor("100"),     # R2 filter
            skip_rest()             # Don't care about remaining values
        )
        print("    ✓ Specific component values validated")

def test_power_decoupling_path(module):
    """Test power decoupling path"""
    print("Testing Power Decoupling:")
    graph = module.graph()
    
    # Test VCC to GND paths (should include decoupling cap)
    paths = graph.paths(start="3V3_VCC", end="GND_GND", max_depth=5)
    print("  Found " + str(len(paths)) + " VCC-to-GND power paths")
    
    for i, path in enumerate(paths):
        print("  Path " + str(i + 1) + ": " + str([c.name for c in path.components]))
        
        # One path should be just the decoupling capacitor
        if len(path.components) == 1:
            print("    Testing direct decoupling path...")
            path.matches(
                is_capacitor("100nF")  # C4 decoupling
            )
            print("      ✓ Direct decoupling capacitor validated")

def test_mixed_patterns(module):
    """Test various mixed component patterns"""
    print("Testing Mixed Patterns:")
    graph = module.graph()
    paths = graph.paths(start="INPUT_INPUT", end="GND_GND", max_depth=15)
    
    if paths:
        # Find a path that goes through C2 to ground
        for path in paths:
            if len(path.components) >= 4:  # Should be a longer path
                print("  Testing path with " + str(len(path.components)) + " components")
                print("  Components: " + str([c.name + "(" + str(c.type) + ")" for c in path.components]))
                
                # Test: Input coupling + filter network ending at ground
                print("    Test: Input-to-ground via filter...")
                path.matches(
                    is_resistor(),    # R1 
                    is_capacitor(),   # C1
                    is_resistor(),    # R2
                    is_inductor(),    # L1
                    is_capacitor()    # C2 to ground
                )
                print("      ✓ Input-to-ground filter path validated")
                break

# Tests that should fail (commented expectations)
def test_failure_cases(module):
    """Test cases that should fail - demonstrating error handling"""
    print("Testing Expected Failures:")
    graph = module.graph()
    paths = graph.paths(start="INPUT_INPUT", end="OUTPUT_OUTPUT", max_depth=15)
    
    if paths:
        path = paths[0]
        
        # This should fail - wrong component type at position 1
        print("  Test: Wrong component type (should fail)...")
        # path.matches(
        #     is_capacitor(),   # Wrong! First component is R1 (resistor)
        #     skip_rest()
        # )
        # Expected: "R1.R is not a capacitor"
        print("    (Commented out - would fail: 'R1.R is not a capacitor')")
        
        # This should fail - wrong value
        print("  Test: Wrong component value (should fail)...")  
        # path.matches(
        #     is_resistor("999kOhm"),  # Wrong! R1 is 1k, not 999k
        #     skip_rest()
        # )
        # Expected: "R1.R value 1k != 999kOhm"
        print("    (Commented out - would fail: 'R1.R value 1k != 999kOhm')")
        
        # This should fail - consuming too many
        print("  Test: Over-consumption (should fail)...")
        # path.matches(
        #     skip(10)  # Wrong! Only 6 components in path
        # )
        # Expected: "skip(10) would consume past end of path"
        print("    (Commented out - would fail: 'skip(10) would consume past end of path')")
        
        # This should fail - under-consumption
        print("  Test: Under-consumption (should fail)...")
        # path.matches(
        #     is_resistor()  # Only consume 1, leave 5 components
        # )
        # Expected: "Unconsumed components remaining (5 left)"
        print("    (Commented out - would fail: 'Unconsumed components remaining (5 left)')")

TestBench(
    name="FilterCircuit", 
    module=FilterModule,
    checks=[
        test_filter_signal_path,
        test_power_decoupling_path,
        test_mixed_patterns,
        test_failure_cases,
    ],
)
