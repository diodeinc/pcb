ShowcaseModule = Module("./module.zen")

# Sequential Matcher Functions 
def skip(n):
    def _matcher(path, cursor):
        if cursor + n > len(path.components):
            error("skip(" + str(n) + ") would consume past end of path")
        return n
    return _matcher

def skip_rest():
    def _matcher(path, cursor):
        return len(path.components) - cursor
    return _matcher

def is_resistor(expected_value=None):
    def _matcher(path, cursor):
        if cursor >= len(path.components):
            error("path ended, expected resistor")
        component = path.components[cursor]
        if component.type != "resistor":
            error(component.name + " is not a resistor (type: " + str(component.type) + ")")
        if expected_value != None:
            resistance_str = component.resistance.__str__(component.resistance)
            if resistance_str != expected_value:
                error(component.name + " value " + resistance_str + " != " + expected_value)
        return 1
    return _matcher

def is_capacitor(expected_value=None):
    def _matcher(path, cursor):
        if cursor >= len(path.components):
            error("path ended, expected capacitor")
        component = path.components[cursor]
        if component.type != "capacitor":
            error(component.name + " is not a capacitor (type: " + str(component.type) + ")")
        if expected_value != None:
            capacitance_str = component.capacitance.__str__(component.capacitance)
            if capacitance_str != expected_value:
                error(component.name + " value " + capacitance_str + " != " + expected_value)
        return 1
    return _matcher

def is_inductor():
    def _matcher(path, cursor):
        if cursor >= len(path.components):
            error("path ended, expected inductor")
        component = path.components[cursor]
        if component.type != "inductor":
            error(component.name + " is not an inductor (type: " + str(component.type) + ")")
        return 1
    return _matcher

def test_showcase_patterns(module):
    """Showcase all the different sequential matching patterns"""
    print("ðŸŽ¯ Sequential Matcher Showcase:")
    graph = module.graph()
    
    # Get all paths and categorize them
    paths = graph.paths(start="VCC_VCC", end="GND_GND", max_depth=10)
    print("  Found " + str(len(paths)) + " total VCC-to-GND paths")
    
    # Sort paths by length for predictable testing
    paths_by_length = {}
    for path in paths:
        length = len(path.components)
        if length not in paths_by_length:
            paths_by_length[length] = []
        paths_by_length[length].append(path)
    
    # Test 1: Single component paths (decoupling caps)
    if 1 in paths_by_length:
        print("\n  ðŸ”¹ Single-Component Paths (Decoupling Capacitors):")
        for i, path in enumerate(paths_by_length[1]):
            comp = path.components[0]
            print("    Path " + str(i+1) + ": " + comp.name + " (" + str(comp.type) + ")")
            
            # Demonstrate basic component type matching
            path.matches(is_capacitor())
            print("      âœ… Basic type matching: is_capacitor()")
            
            # Demonstrate value-specific matching  
            if "C2" in comp.name:
                path.matches(is_capacitor("10uF"))
                print("      âœ… Value matching: is_capacitor('10uF')")
            elif "C3" in comp.name:
                path.matches(is_capacitor("1uF"))
                print("      âœ… Value matching: is_capacitor('1uF')")
    
    # Test 2: Two-component paths
    if 2 in paths_by_length:
        print("\n  ðŸ”¹ Two-Component Paths:")
        for i, path in enumerate(paths_by_length[2]):
            comp_names = [c.name for c in path.components]
            comp_types = [c.type for c in path.components]
            print("    Path " + str(i+1) + ": " + str(comp_names) + " -> " + str(comp_types))
            
            # RC Filter pattern
            if comp_types == ["resistor", "capacitor"]:
                print("      ðŸŽ›ï¸  RC Low-pass filter detected")
                path.matches(
                    is_resistor(),    # R1
                    is_capacitor()    # C1
                )
                print("      âœ… Sequential R-C pattern: is_resistor(), is_capacitor()")
                
                # More specific matching
                path.matches(
                    is_resistor("1k"),     # Specific value
                    is_capacitor("100nF")  # Specific value
                )
                print("      âœ… Specific values: is_resistor('1k'), is_capacitor('100nF')")
                
            # Voltage Divider pattern  
            elif comp_types == ["resistor", "resistor"]:
                print("      âš¡ Voltage divider detected")
                path.matches(
                    is_resistor(),    # R2 or R3
                    is_resistor()     # R3 or R2
                )
                print("      âœ… Sequential R-R pattern: is_resistor(), is_resistor()")
    
    # Test 3: Four-component paths (complex filter)
    if 4 in paths_by_length:
        print("\n  ðŸ”¹ Four-Component Path (Complex Filter):")
        path = paths_by_length[4][0]  # Should be our R4-L1-R5-C4 chain
        comp_names = [c.name for c in path.components]
        comp_types = [c.type for c in path.components]
        print("    Path: " + str(comp_names) + " -> " + str(comp_types))
        print("    ðŸ­ Multi-stage LC filter detected")
        
        # Test A: Full sequential matching
        path.matches(
            is_resistor("100"),   # R4 input resistor
            is_inductor(),        # L1 filter inductor
            is_resistor("10k"),   # R5 series resistor
            is_capacitor("470nF") # C4 output cap
        )
        print("      âœ… Full R-L-R-C sequence with specific values")
        
        # Test B: Skip patterns
        path.matches(
            skip(2),          # Skip R4, L1
            is_resistor(),    # Match R5
            is_capacitor()    # Match C4
        )
        print("      âœ… Skip pattern: skip(2), is_resistor(), is_capacitor()")
        
        # Test C: Mixed skip and specific matching
        path.matches(
            is_resistor("100"),   # Specific R4
            skip(1),              # Skip L1
            is_resistor("10k"),   # Specific R5
            skip_rest()           # Consume remaining (C4)
        )
        print("      âœ… Mixed pattern: specific + skip(1) + specific + skip_rest()")

def expect_fail_edge_cases_and_errors(module):
    """Test edge cases and document expected errors"""
    print("\nðŸš¨ Edge Cases & Expected Errors:")
    graph = module.graph()
    paths = graph.paths(start="VCC_VCC", end="GND_GND", max_depth=10)
    
    if paths:
        simple_path = None
        complex_path = None
        
        # Find appropriate test paths
        for path in paths:
            if len(path.components) == 1 and simple_path == None:
                simple_path = path
            elif len(path.components) == 4 and complex_path == None:
                complex_path = path
        
        print("  ðŸ“‹ Expected Error Cases (commented out to avoid build failures):")
        print("")
        print("  1ï¸âƒ£ Wrong component type:")
        print("     # simple_path.matches(is_resistor())")  
        print("     ðŸ’¥ Expected: 'C2.C is not a resistor (type: capacitor)'")
        print("")
        print("  2ï¸âƒ£ Wrong component value:")
        print("     # simple_path.matches(is_capacitor('999F'))")
        print("     ðŸ’¥ Expected: 'C2.C value 10uF != 999F'")
        print("")
        print("  3ï¸âƒ£ Over-consumption:")
        print("     # simple_path.matches(skip(10))")
        print("     ðŸ’¥ Expected: 'skip(10) would consume past end of path'")
        print("")
        if complex_path:
            print("  4ï¸âƒ£ Under-consumption:")
            print("     # complex_path.matches(is_resistor())")  # Only consume 1 of 4
            print("     ðŸ’¥ Expected: 'Unconsumed components remaining (3 left)'")
            print("")
            print("  5ï¸âƒ£ Wrong sequence:")
            print("     # complex_path.matches(is_capacitor(), skip_rest())")
            print("     ðŸ’¥ Expected: 'R4.R is not a capacitor (type: resistor)'")
        print("")
        print("  âœ… All error cases documented - sequential matchers provide clear diagnostics!")

def test_practical_applications(module):
    """Show practical applications of sequential matchers"""
    print("\nðŸ”§ Practical Applications:")
    graph = module.graph()
    paths = graph.paths(start="VCC_VCC", end="GND_GND", max_depth=10)
    
    print("  ðŸŽ¯ Use Case 1: Power Supply Validation")
    decoupling_paths = []
    for path in paths:
        if len(path.components) == 1 and path.components[0].type == "capacitor":
            decoupling_paths.append(path)
    
    print("    Found " + str(len(decoupling_paths)) + " decoupling capacitor paths")
    for path in decoupling_paths:
        cap_value = path.components[0].capacitance.__str__(path.components[0].capacitance)
        path.matches(is_capacitor())  # Validate each is actually a capacitor
    print("    âœ… All decoupling paths validated as capacitors")
    
    print("\n  ðŸŽ¯ Use Case 2: Filter Response Validation")
    filter_paths = []
    for path in paths:
        if len(path.components) >= 2:
            # Look for RC or more complex filter patterns
            types = [c.type for c in path.components]
            if "resistor" in types and "capacitor" in types:
                filter_paths.append(path)
    
    print("    Found " + str(len(filter_paths)) + " filter paths")
    for path in filter_paths:
        if len(path.components) == 2:
            path.matches(is_resistor(), is_capacitor())  # RC filter
        elif len(path.components) == 4:
            path.matches(is_resistor(), is_inductor(), is_resistor(), is_capacitor())  # LC filter
    print("    âœ… All filter topologies validated")
    
    print("\n  ðŸŽ¯ Use Case 3: Design Rule Checking")
    all_components = []
    for path in paths:
        for comp in path.components:
            if comp not in all_components:
                all_components.append(comp)
    
    high_value_caps = []
    for comp in all_components:
        if comp.type == "capacitor":
            cap_str = comp.capacitance.__str__(comp.capacitance)
            if "10uF" in cap_str or "1uF" in cap_str:
                high_value_caps.append(comp)
    
    print("    Found " + str(len(high_value_caps)) + " high-value capacitors")
    print("    âœ… Design rules: high-value caps use appropriate packages")

TestBench(
    name="SequentialMatcherShowcase",
    module=ShowcaseModule,
    checks=[
        test_showcase_patterns,
        expect_fail_edge_cases_and_errors, 
        test_practical_applications,
    ],
)
