---
title: "Zener Language"
description: "Hardware Description Language for PCB design"
---

# Specification

## Overview

Zener is a domain-specific language built on top of
[Starlark](https://github.com/bazelbuild/starlark/blob/master/spec.md) for
describing PCB schematics. It provides primitives for defining components, symbols, nets,
interfaces, and modules in a type-safe, composable manner.

This specification describes the language extensions and primitives added on top
of Starlark. For the base Starlark language features, please refer to the
[Starlark specification](https://github.com/bazelbuild/starlark/blob/master/spec.md) and the
[starlark-rust types extension](https://github.com/facebook/starlark-rust/blob/main/docs/types.md).

## Table of Contents

1. [Modules and Imports](#modules-and-imports)
2. [Core Types](#core-types)
3. [Built-in Functions](#built-in-functions)

## Modules and Imports

### Files as Modules

Each `.zen` file is a Starlark module. It can be used in two ways:

1. Its exported symbols can be `load()`ed into other modules. For example,
   `load("./MyFile.zen", "MyFunction", "MyType")` will load the `MyFunction`
   and `MyType` symbols from the `MyFile.zen` module.
2. It can be loaded as a schematic module using the `Module()` helper. For
   example, `MyFile = Module("./MyFile.zen")` will import `MyFile.zen` as a
   schematic module, which you can instantiate like so:
   ```python
   MyFile = Module("./MyFile.zen")
   MyFile(
       name = "MyFile",
       ...
   )
   ```

### Load Resolution

The `load()` and `Module()` statements support multiple resolution strategies:

```python
# Local file (relative to current file)
load("./utils.zen", "helper")

# Stdlib (version controlled by toolchain)
load("@stdlib/units.zen", "kohm", "uF")
load("@stdlib/interfaces.zen", "Power", "Ground", "Spi")

# Load as Module for instantiation
Resistor = Module("@stdlib/generics/Resistor.zen")
TPS54331 = Module("github.com/diodeinc/registry/reference/TPS54331/TPS54331.zen")
```

Import paths use full domain-based URLs without version information. Versions are declared separately in `pcb.toml`:

```toml
[dependencies]
"github.com/diodeinc/stdlib" = "0.3"
"github.com/diodeinc/registry/reference/TPS54331" = "1.0"
```

This separation means import statements remain stable across version upgrades.

#### The @stdlib Alias

The `@stdlib` alias is special: its version is controlled by the `pcb` toolchain, not by user configuration. This ensures stdlib is always compatible with your toolchain version. You don't need to declare stdlib in your `[dependencies]` - it's implicitly available.

```python
# Load from stdlib (version determined by toolchain)
load("@stdlib/units.zen", "kohm", "uF")
load("@stdlib/board_config.zen", "Board")
```

Note: You can override stdlib to a *newer* version than the toolchain default by declaring it in `[dependencies]`, but you cannot use an older version.

#### Development Dependencies

For unreleased code, you can reference branches or specific commits:

```toml
[dependencies]
# Branch reference - resolved to a pseudo-version
"github.com/diodeinc/stdlib" = { branch = "main" }

# Specific commit
"github.com/myorg/mylib" = { rev = "a1b2c3d4" }

# Path dependency (local development)
"github.com/myorg/mylib" = { path = "../mylib" }
```

### Automatic Dependency Management

Dependencies are automatically resolved when you import a package. When you use a package URL in `load()` or `Module()`, the toolchain:

1. **Discovers the dependency** from your import path
2. **Resolves the version** using Minimal Version Selection (MVS)
3. **Downloads and caches** the package locally
4. **Adds the dependency** to `pcb.toml` if not already present

This means you can start using a new package simply by importing it—no manual dependency declaration required for initial setup.

#### Minimal Version Selection (MVS)

The dependency resolver uses Minimal Version Selection, which selects the *minimum* version that satisfies all constraints rather than the newest available. This provides:

- **Deterministic builds**: The same code always resolves to the same versions, regardless of what new versions exist upstream
- **Tested combinations**: You get the versions that package authors actually tested with
- **No solver complexity**: Resolution is fast and predictable with clear error messages

When multiple packages require the same dependency, MVS selects the highest of their minimum requirements:

```
Your board requires: usb-pd-controller >= 1.0.0
Power module requires: usb-pd-controller >= 1.0.3

Result: usb-pd-controller@1.0.3 (satisfies both)
```

To upgrade to newer versions, explicitly declare them in `pcb.toml`:

```toml
[dependencies]
"github.com/diodeinc/registry/modules/UsbPdController" = "1.2"  # Explicitly request newer version
```

#### Lockfile

The lockfile (`pcb.sum`) records exact versions and cryptographic hashes of all dependencies. This ensures:

- **Reproducibility**: Builds use identical dependencies across machines and time
- **Integrity**: Any tampering or corruption is detected via hash verification

Commit `pcb.sum` to version control to ensure all team members use the same dependency versions.

See the [Packages](/pages/packages) documentation for complete details on version resolution, coexisting versions, and dependency commands.

### Project Manifest (pcb.toml)

Every Zener project has a `pcb.toml` manifest file that defines the project structure and dependencies.

#### Workspaces

A workspace is a collection of related packages (boards, modules, components) that are developed together:

```toml
[workspace]
members = [
    "boards/*",
    "modules/*",
]
```

The `members` field uses glob patterns to include packages. Each member must have its own `pcb.toml`.

#### Package Definition

Each package declares its identity and metadata:

```toml
[package]
name = "my-board"
description = "A custom development board"
```

For publishable packages, the package URL is derived from the git remote (e.g., `github.com/myorg/myrepo/boards/my-board`).

#### Dependencies

Dependencies are declared with version constraints:

```toml
[dependencies]
"github.com/diodeinc/stdlib" = "0.3"
"github.com/diodeinc/registry/reference/TPS54331" = "1.0"

# Development dependencies
"github.com/diodeinc/stdlib" = { branch = "main" }
"github.com/myorg/mylib" = { path = "../mylib" }
```

Dependencies are also auto-added when you import a new package in your `.zen` files.

#### Patches

Patches override remote packages with local versions. Use sparingly—patches bypass version locking and can cause unreproducible builds:

```toml
[patch."github.com/diodeinc/registry/modules/PowerSupply"]
path = "fork/github.com/diodeinc/registry/modules/PowerSupply/1.0.0"
```

Prefer publishing fixes upstream or using path dependencies during active development.

See the [Packages](/pages/packages) documentation for complete manifest reference and CLI commands.

## Core Types

### Net

A `Net` represents an electrical connection between component pins. Nets can optionally specify electrical properties like impedance, voltage range, and schematic symbols.

```python
# Create a net with optional name
net1 = Net()
net2 = Net("VCC")

# Net with impedance (for controlled impedance routing)
load("@stdlib/units.zen", "Impedance")
clk = Net("CLK", impedance=Impedance(50))  # 50Ω single-ended

# Net with voltage range
load("@stdlib/units.zen", "VoltageRange")
vdd = Net("VDD_3V3", voltage=VoltageRange("3.0V to 3.6V"))

# Net with custom schematic symbol
vcc_sym = Symbol(library="@kicad-symbols/power.kicad_sym", name="VCC")
vcc = Net("VCC", symbol=vcc_sym)
```

**Type**: `Net`
**Constructor**: `Net(name="", symbol=None, voltage=None, impedance=None)`

- `name` (optional): String identifier for the net
- `symbol` (optional): Symbol object for schematic representation
- `voltage` (optional): VoltageRange specification for the net
- `impedance` (optional): Impedance specification for single-ended nets (in Ohms)

### Symbol

A `Symbol` represents a schematic symbol definition with its pins. Symbols can be created manually or loaded from KiCad symbol libraries.

```python
# Local symbol file (in same directory as .zen file)
ic_symbol = Symbol(library="TCA9554DBR.kicad_sym")

# KiCad library symbol via @kicad-symbols alias
connector = Symbol(library="@kicad-symbols/Connector_Generic.kicad_sym", name="Conn_01x14")
gnd = Symbol("@kicad-symbols/power.kicad_sym:GND")

# Explicit pin definition (less common)
my_symbol = Symbol(
    name = "MyDevice",
    definition = [
        ("VCC", ["1", "8"]),    # VCC on pins 1 and 8
        ("GND", ["4"]),         # GND on pin 4
        ("IN", ["2"]),          # IN on pin 2
        ("OUT", ["7"])          # OUT on pin 7
    ]
)
```

**Type**: `Symbol`  
**Constructor**: `Symbol(library_spec=None, name=None, definition=None, library=None)`

- `library_spec`: (positional) String in format "library_path:symbol_name" or just "library_path" for single-symbol libraries
- `name`: Symbol name (required when loading from multi-symbol library with named parameters)
- `definition`: List of (signal_name, [pad_numbers]) tuples
- `library`: Path to KiCad symbol library file

Note: You cannot mix the positional `library_spec` argument with the named `library` or `name` parameters.

### Component

Components represent physical electronic parts with pins and properties.

```python
# Using a Symbol for pin definitions
my_symbol = Symbol(
    definition = [
        ("VCC", ["1"]),
        ("GND", ["4"]),
        ("OUT", ["8"])
    ]
)

Component(
    name = "U1",                   # Required: instance name
    footprint = "SOIC-8",          # Required: PCB footprint
    symbol = my_symbol,            # Symbol defines the pins
    pins = {                       # Required: pin connections
        "VCC": vcc_net,
        "GND": gnd_net,
        "OUT": output_net
    },
    prefix = "U",                  # Optional: reference designator prefix (default: "U")
    mpn = "LM358",                 # Optional: manufacturer part number
    type = "op-amp",               # Optional: component type
    properties = {                 # Optional: additional properties
        "voltage": "5V"
    }
)
```

**Type**: `Component`  
**Constructor**: `Component(**kwargs)`

Key parameters:

- `name`: Instance name (required)
- `footprint`: PCB footprint (required)
- `symbol`: Symbol object defining pins (required)
- `pins`: Pin connections to nets (required)
- `prefix`: Reference designator prefix (default: "U")
- `mpn`: Manufacturer part number
- `type`: Component type
- `properties`: Additional properties dict

### Interface

Interfaces define reusable connection patterns with field specifications and type validation. Interfaces can specify impedance requirements that automatically propagate to their constituent nets during layout.

**Differential Pair Example:**

```python
load("@stdlib/units.zen", "Impedance")

# DiffPair interface with 90Ω differential impedance
DiffPair = interface(
    P=Net(),
    N=Net(),
    impedance=field(Impedance, None),  # Optional impedance
)

# USB interface uses DiffPair with 90Ω impedance
Usb2 = interface(
    D=DiffPair(impedance=Impedance(90)),
)

# When instantiated, impedance automatically propagates to P/N nets
usb = Usb2("USB")  # USB.D.P and USB.D.N both get 90Ω differential impedance
```

The impedance from DiffPair interfaces is stored as `differential_impedance` on the P and N nets, allowing the layout system to assign appropriate netclasses for differential pair routing.

#### Basic Syntax

```python
InterfaceName = interface(
    field_name = field_specification,
)
```

#### Field Types

**Net Instances**: Use the provided Net instance as the default template
```python
NET = Net("VCC", symbol = Symbol(library = "@kicad-symbols/power.kicad_sym", name = "VCC"))
SDA = Net("I2C_SDA")
```

**Interface Instances**: Use interfaces for composition
```python
uart = Uart(TX=Net("UART_TX"), RX=Net("UART_RX"))
```

**field() Specifications**: Enforce type checking with explicit defaults
```python
voltage = field(Voltage, unit("3.3V", Voltage))
freqs = field(list[str], ["100kHz", "400kHz"])
count = field(int, 42)
```

#### Interface Instantiation

```python
InterfaceName([name], field1=value1, field2=value2, ...)
```

- **Optional name**: First positional argument sets the interface instance name
- **Field overrides**: Named parameters override defaults
- **Type validation**: Values must match field specifications

#### Examples

```python
# Define interfaces for grouped signals
Uart = interface(
    TX = Net("UART_TX"),
    RX = Net("UART_RX"),
)

Spi = interface(
    CLK = Net("SPI_CLK"),
    MOSI = Net("SPI_MOSI"),
    MISO = Net("SPI_MISO"),
    CS = Net("SPI_CS"),
)

# Compose interfaces
SystemInterface = interface(
    uart = Uart(),
    spi = Spi(),
    debug = field(bool, False),
)

# Create instances
uart = Uart("DEBUG_UART")
system = SystemInterface("MAIN", debug=True)
```

Note: `Power` and `Ground` are net types from `@stdlib/interfaces.zen`, not interfaces. Use them like:
```python
load("@stdlib/interfaces.zen", "Power", "Ground")
vcc = Power("VCC_3V3", voltage=VoltageRange("3.3V"))
gnd = Ground("GND")
```

**Type**: `interface`  
**Constructor**: `interface(**fields)`

- Fields can be Net instances, interface instances, or `field()` specifications

### Module

Modules represent hierarchical subcircuits that can be instantiated multiple times.

**Defining a module** (`voltage_divider.zen`):
```python
# Declare IO ports
vin = io("vin", Net)
vout = io("vout", Net)
gnd = io("gnd", Net)

# Declare configuration parameters
r1_value = config("r1", str, default="10k")
r2_value = config("r2", str, default="10k")

# Load generic components
Resistor = Module("@stdlib/generics/Resistor.zen")

# Create the subcircuit
Resistor(name="R1", value=r1_value, P1=vin, P2=vout)
Resistor(name="R2", value=r2_value, P1=vout, P2=gnd)
```

**Instantiating a module**:
```python
VDivider = Module("./voltage_divider.zen")

VDivider(
    name = "divider1",
    vin = vcc,
    vout = feedback,
    gnd = gnd,
    r1 = "100k",
    r2 = "47k"
)
```

**Type**: `Module`
**Constructor**: `Module(path)`

For module introspection and testing, see the [Testing](/pages/testing) documentation.

### PhysicalRange

A `PhysicalRange` represents a bounded range of physical values with an optional nominal value, used for specifying operating ranges, tolerances, and electrical characteristics. Ranges have minimum and maximum bounds with consistent physical units.

```python
# PhysicalRange values are created by unit-specific range constructors
# (See builtin.physical_range() in Built-in Functions)

# String parsing with range separators
voltage_range = VoltageRange("1.1–3.6V")              # 1.1–3.6 V
supply_range = VoltageRange("11V to 26V")             # 11–26 V

# With nominal value in parentheses
input_range = VoltageRange("11–26 V (12 V nom.)")     # 11–26 V (12 V nom.)

# Tolerance expansion
nominal_voltage = VoltageRange("15V 10%")             # 13.5–16.5 V

# From PhysicalValue
single_point = VoltageRange(Voltage(15))              # 15–15 V

# Keyword arguments
operating_range = VoltageRange(min=11, nominal=16, max=26)  # 11–26 V (16 V nom.)

# Mixed string/number keywords
custom_range = VoltageRange(min="11V", nominal="16", max="26V")  # 11–26 V (16 V nom.)

# Override nominal separately
with_nominal = VoltageRange("11V to 26V", nominal="16V")  # 11–26 V (16 V nom.)
```

**Type**: `PhysicalRange`
**Created by**: Unit-specific range constructors (e.g., `VoltageRange`, `CurrentRange`)

Properties:
- `min`: Minimum value (Decimal)
- `max`: Maximum value (Decimal)
- `nominal`: Optional nominal/typical value (Decimal or None)
- `unit`: Physical unit dimensions

**Display Format**:
- With nominal: `11–26 V (12 V nom.)`
- Without nominal: `11–26 V`

**Methods**:

- `.diff(other)` - Returns the maximum possible absolute difference between two ranges
  - `other`: Another PhysicalRange or string (e.g., `"0V"`, `"1.7V to 2.0V"`)
  - Returns PhysicalValue with the worst-case difference
  - Units must match or an error is raised
  - Tolerance is always zero (like PhysicalValue.diff())
  - Useful for determining component voltage ratings (capacitors, level shifters, etc.)

**Operators**:

- **Addition** (`+`) - Shift a range by a value
  - `range + value` returns a new range with min/max/nominal shifted by the value
  - Units must match (or value must be dimensionless)
  - The value's tolerance is ignored (only the numeric value is used)

- **Subtraction** (`-`) - Shift a range down by a value
  - `range - value` returns a new range with min/max/nominal shifted down by the value
  - Units must match (or value must be dimensionless)

- **Comparison** (`<`, `>`, `<=`, `>=`) - Compare ranges using conservative semantics
  - `range1 < range2` is true iff `range1.max < range2.min` (entire range1 is strictly below range2)
  - `range1 > range2` is true iff `range1.min > range2.max` (entire range1 is strictly above range2)
  - For overlapping ranges, `max` values are compared as a tiebreaker
  - Can compare with: `PhysicalRange`, `PhysicalValue`, or string values
  - Units must be compatible or an error is raised

- **Equality** (`==`) - Check if two ranges are identical
  - Returns true if `min`, `max`, `nominal`, and `unit` all match
  - Can compare with: `PhysicalRange` or string values

- **Containment** (`in`) - Check if a value fits within the range
  - `value in range` returns true if value's bounds fit entirely within range's bounds
  - Works with `PhysicalValue`, `PhysicalRange`, or string values

- **Unary negation** (`-`) - Negate the range
  - Returns a new range with negated min/max (swapped) and negated nominal

**Examples**:

```python
# Capacitor voltage rating
vcc = VoltageRange("3.0V to 3.6V")
cap_rating = vcc.diff("0V")  # 3.6V

# Level shifter between two rails
v_high = VoltageRange("3.0V to 3.6V")
max_diff = v_high.diff("1.7V to 2.0V")  # 1.9V

# Range comparison (conservative semantics)
low_voltage = VoltageRange("1V to 2V")
high_voltage = VoltageRange("3V to 4V")
low_voltage < high_voltage   # True (2V < 3V)
low_voltage <= high_voltage  # True

# Overlapping ranges
range1 = VoltageRange("1V to 3V")
range2 = VoltageRange("2V to 4V")
range1 < range2  # False (ranges overlap, but 3V < 4V so Less by tiebreaker)

# Comparing range to value
input_range = VoltageRange("3.3V to 5V")
if input_range <= VoltageRange("3.3V"):
    # Input is entirely within 3.3V rail
    pass

# Equality
VoltageRange("1V to 2V") == VoltageRange("1V to 2V")  # True
VoltageRange("1V to 2V") == VoltageRange("1V to 2V (1.5V nom.)")  # False (different nominal)

# Range arithmetic (shifting ranges)
base_range = VoltageRange("1V to 2V")
shifted_up = base_range + Voltage("3V")    # 4V to 5V
shifted_down = base_range - Voltage("0.5V")  # 0.5V to 1.5V

# With nominal values preserved
input_range = VoltageRange("1V to 3V (2V nom.)")
offset_range = input_range + Voltage("5V")  # 6V to 8V (7V nom.)
```

#### PhysicalRangeType

A `PhysicalRangeType` is a factory type that creates `PhysicalRange` instances for a specific physical unit. Each unit has its own range type (e.g., `VoltageRange` for volts, `CurrentRange` for amperes).

```python
# Range types are created by builtin.physical_range()
VoltageRange = builtin.physical_range("V")
CurrentRange = builtin.physical_range("A")

# Range types are callable and return PhysicalRange instances
input_voltage = VoltageRange("3.3V to 5V")
load_current = CurrentRange("100mA to 500mA")
```

**Type**: `PhysicalRangeType`
**Created by**: `builtin.physical_range(unit)` (see [Built-in Functions](#builtinphysical_rangeunit))

**Standard Range Types** (available in `@stdlib/units.zen`):
- `VoltageRange` - Voltage ranges (V)
- `CurrentRange` - Current ranges (A)
- `ResistanceRange` - Resistance ranges (Ω)
- `CapacitanceRange` - Capacitance ranges (F)
- `InductanceRange` - Inductance ranges (H)
- `FrequencyRange` - Frequency ranges (Hz)
- `TemperatureRange` - Temperature ranges (K)
- `TimeRange` - Time ranges (s)
- `PowerRange` - Power ranges (W)

**Construction Flexibility**:

Range constructors accept multiple input formats for maximum flexibility:

1. **String parsing with separators**:
   - En-dash: `"1.1–3.6V"`
   - Word "to": `"11V to 26V"`
   - Left side can omit unit: `"11–26V"`

2. **Nominal value extraction**:
   - Parenthesized suffix: `"11–26 V (12 V nom.)"`
   - Can be combined with string ranges or keyword override

3. **Tolerance expansion**:
   - Percentage tolerance: `"15V 10%"` expands to `13.5–16.5 V`

4. **PhysicalValue conversion**:
   - Single value: `VoltageRange(Voltage(15))` creates point range `15–15 V`
   - Toleranced value: `VoltageRange(Voltage(15, 0.1))` expands tolerance to range

5. **Keyword arguments**:
   - Explicit bounds: `min=11, max=26`
   - With nominal: `min=11, nominal=16, max=26`
   - Accepts numbers or strings: `min="11V"`, `max="26V"`

6. **Mixed modes**:
   - String range with keyword nominal: `VoltageRange("11V to 26V", nominal="16V")`

**Type Safety**:
- Units must be consistent across min, max, and nominal values
- Range types are distinct: `VoltageRange` ≠ `CurrentRange`
- Type checking enforces unit correctness at compile time

**Use Cases**:
- Component operating ranges: `input_voltage = VoltageRange("2.7V to 5.5V")`
- Load specifications: `output_current = CurrentRange("0A to 3A")`
- Environmental conditions: `operating_temp = TemperatureRange("-40C to 85C")`
- Future: Electrical Rule Checking (ERC) - validate that supply ranges satisfy load requirements

## Built-in Functions

### moved(old_path, new_path)

**Parameters**

- `old_path`: The old path that should be remapped
- `new_path`: The new path to remap to

The `moved()` directive allows you to specify path remapping for refactoring support. When modules or components are moved or renamed, downstream artifacts (like layout files) may still reference the old paths. The `moved()` directive provides a mapping from old paths to new paths.

`moved()` directives are scoped to the module where they are defined. They affect how paths from that module are resolved in downstream artifacts.

If the path refers to a module, all children of that module are automatically remapped:

```python
# This single directive handles:
# POW.PS1 -> PS1
# POW.PS1.some_resistor -> PS1.some_resistor  
# POW.PS1.inner.component -> PS1.inner.component
moved("POW.PS1", "PS1")
```

```python
# Moved a power supply module from POW namespace to root
moved("POW.PS1", "PS1")

# Renamed a component
moved("OLD_COMP", "NEW_COMP")

# Moved components between modules
moved("ModuleA.ComponentX", "ModuleB.ComponentX")

# Net remapping for position comments
moved("AN_OLD_FILTERED_VCC_VCC", "FILTERED_VCC_VCC")
```

### io(name, type, checks=None, default=None, optional=False)

Declares a net or interface input for a module.

```python
# Required net input
vcc = io("vcc", Net)

# Net type input (Power, Ground from @stdlib/interfaces.zen)
load("@stdlib/interfaces.zen", "Power", "Ground")
power = io("power", Power)
gnd = io("gnd", Ground)

# With explicit default
data = io("data", Net, default=Net("DATA"))

# With validation checks (single function)
def check_voltage_within(within):
    def check_fn(power_value):
        voltage = power_value.voltage
        check(voltage.min >= within.min and voltage.max <= within.max,
              f"Voltage {voltage} not within {within}")
    return check_fn

vbat = io("VBAT", Power, check_voltage_within(VoltageRange("10–30 V")))

# Or with multiple checks as a list
vbat = io("VBAT", Power, [check_voltage_within(VoltageRange("10–30 V")), check_current()])

# Or as a named argument
vbat = io("VBAT", Power, checks=check_voltage_within(VoltageRange("10–30 V")))
```

**Parameters:**

- `name`: String identifier for the input (positional)
- `type`: Expected type - `Net` or interface type (positional)
- `checks`: Optional check function or list of check functions to run on the value at eval time (3rd positional or named)
- `default`: Default value if not provided by parent (named)
- `optional`: If True, returns None when not provided (unless default is specified) (named)

### config(name, type, default=None, convert=None, optional=False)

Declares a configuration value input for a module.

```python
# String configuration
prefix = config("prefix", str, default="U")

# Integer with conversion
baudrate = config("baudrate", int, convert=int)

# Enum configuration
Direction = enum("NORTH", "SOUTH", "EAST", "WEST")
heading = config("heading", Direction)

# Optional configuration
debug = config("debug", bool, optional=True)
```

**Parameters:**

- `name`: String identifier for the input
- `type`: Expected type (str, int, float, bool, enum, or record type)
- `default`: Default value if not provided
- `convert`: Optional conversion function
- `optional`: If True, returns None when not provided (unless default is specified)

### File(path)

Resolves a file or directory path using the load resolver.

```python
# Get absolute path to a file
config_path = File("./config.json")

# Works with load resolver syntax
stdlib_path = File("@stdlib/components")
```

### Path(path, allow_not_exist=False)

Advanced path resolution supporting all LoadSpec formats with optional existence checking.

```python
# Basic path resolution (same as File)
config_path = Path("./config.json")

# LoadSpec format support
stdlib_path = Path("@stdlib/components")
github_path = Path("github.com/user/repo/path.zen")

# Allow non-existent paths (only works with local paths)
optional_file = Path("./optional.zen", allow_not_exist=True)
```

**Parameters:**

- `path`: String path to resolve (supports any LoadSpec format)
- `allow_not_exist`: Optional boolean (default: False). If True, allows non-existent paths. Can only be used with local path LoadSpecs, not package/GitHub/GitLab specs.

### error(msg, suppress=False, kind=None)

Raises a runtime error with the given message. With `suppress=True`, the error is rendered but doesn't stop evaluation or fail the build.

```python
# Basic error (stops evaluation)
if not condition:
    error("Condition failed")

# Suppressed error (rendered but doesn't fail build)
error("Non-critical issue detected", suppress=True)

# Categorized error for filtering
error("Voltage out of range", suppress=True, kind="electrical.voltage")
```

**Parameters:**
- `msg`: Error message (required)
- `suppress`: If True, renders diagnostic but doesn't stop evaluation or fail build (default: False)
- `kind`: Optional diagnostic kind for filtering/categorization (e.g., "electrical.voltage_mismatch")

### check(condition, msg)

Checks a condition and raises an error if false.

```python
check(voltage > 0, "Voltage must be positive")
check(len(pins) == 8, "Expected 8 pins")
```

### warn(msg, suppress=False, kind=None)

Emits a warning diagnostic with the given message and continues execution. Unlike `error()`, this does not stop evaluation.

```python
# Basic warning
warn("Component value is outside typical range")

# Suppressed warning (won't fail build with -Dwarnings)
warn("Optimization suggestion", suppress=True)

# Categorized warning for filtering
warn("High current detected", kind="electrical.current")
warn("Trace too narrow", kind="layout.spacing")
```

**Parameters:**
- `msg`: Warning message (required)
- `suppress`: If True, won't cause build failure with `-Dwarnings` flag (default: False)
- `kind`: Optional diagnostic kind for filtering/categorization (e.g., "electrical.overvoltage")

**Diagnostic Kinds:**

The `kind` parameter enables hierarchical categorization of diagnostics for filtering at the CLI level:

```python
# Categorize by domain
warn("Voltage exceeds spec", kind="electrical")
warn("Trace spacing too narrow", kind="layout")
warn("Missing part number", kind="bom")

# Hierarchical kinds use dot-separated segments
warn("Overvoltage detected", kind="electrical.voltage.overvoltage")
warn("Trace clearance violation", kind="layout.spacing.clearance")
```

Kinds can be suppressed at build time using the `-S` flag with hierarchical matching:
- `-S electrical` suppresses all electrical.* warnings
- `-S electrical.voltage` suppresses electrical.voltage.* warnings
- `-S warnings` suppresses all warnings regardless of kind
- `-S errors` suppresses all errors regardless of kind

### add_property(name, value)

Adds a property to the current module instance.

```python
add_property("layout_group", "power_supply")
add_property("critical", True)
```

### builtin.net_type(type_name, **fields)

**Built-in function** that creates custom typed net constructors with optional field parameters. The stdlib uses this to define `Power`, `Ground`, and other net types.

```python
# Create a typed net with field() specifications
load("@stdlib/units.zen", "VoltageRange")
MyPower = builtin.net_type("MyPower",
    voltage=VoltageRange,
    symbol=field(Symbol, default=Symbol(library="@kicad-symbols/power.kicad_sym", name="VCC"))
)

# Create a typed net with direct type constructors (no defaults)
Clock = builtin.net_type("Clock", frequency=int)

# Create a typed net with enum fields
Level = enum("LOW", "HIGH")
DigitalSignal = builtin.net_type("DigitalSignal", level=Level)
```

Note: `Power` and `Ground` net types are already provided by `@stdlib/interfaces.zen`.

**Parameters:**

- `type_name`: String name for the net type (required, positional)
- `**fields`: Keyword arguments defining optional typed fields
  - Each field can be a `field()` spec (with default), a type constructor (str/int/float/bool), an enum type, or a physical value type

**Field Specifications:**

Fields accept any of these specifications:

- `field(type, default)` - Typed field with a default value (from starlark's builtin `field()`)
- `str`, `int`, `float`, `bool` - Direct type constructors (no default)
- `EnumType` - Enum type created with `enum()`
- `Voltage`, `Current`, etc. - Physical value types from stdlib

**Usage:**

All fields are **optional** during net instantiation - you can create a net without providing any field values:

```python
Power = builtin.net_type("Power", voltage=field(str, "3.3V"), max_current=field(int, 1000))

# Provide all fields
vcc = Power("VCC", voltage="5V", max_current=2000)

# Provide some fields (others get defaults from field() specs)
vdd = Power("VDD", voltage="3.3V")  # max_current uses default 1000

# Provide no fields (all use defaults from field() specs)
v3v3 = Power("3V3")  # voltage="3.3V", max_current=1000

# Access field values as attributes
print(vcc.voltage)        # "5V"
print(vcc.max_current)    # 2000
```

**Field Access:**

- Fields can be accessed as attributes on net instances: `net.field_name`
- If a field was not provided and has no default, accessing it will fail
- Fields are stored in the net's properties and can be introspected

**Type Validation:**

- Field values are validated at net instantiation time using starlark's type system
- Type mismatches produce clear error messages:
  ```python
  Power = builtin.net_type("Power", voltage=str)
  vcc = Power("VCC", voltage=123)  # Error: Field 'voltage' has wrong type: expected str, got int
  ```
- Validation works uniformly for all type specifications: builtin types, field() wrappers, enums, and custom types

**Typical Use Cases:**

```python
# Power nets with voltage specifications
Power = builtin.net_type("Power", voltage=field(str, "3.3V"))
vcc_3v3 = Power("VCC_3V3", voltage="3.3V")
vcc_5v = Power("VCC_5V", voltage="5V")

# Clock signals with frequency metadata
Clock = builtin.net_type("Clock", frequency=int)
main_clk = Clock("MAIN_CLK", frequency=8000000)
rtc_clk = Clock("RTC_CLK", frequency=32768)

# Digital signals with logic level
Level = enum("1V8", "3V3", "5V")
Gpio = builtin.net_type("Gpio", level=Level)
gpio_pin = Gpio("GPIO_1", level=Level("3V3"))

# Power rails with electrical specifications
load("@stdlib/units.zen", "Voltage", "Current", "unit")
PowerRail = builtin.net_type("PowerRail", 
    nominal_voltage=Voltage,
    max_current=Current
)
main_rail = PowerRail("MAIN_RAIL",
    nominal_voltage=unit("3.3V", Voltage),
    max_current=unit("2A", Current)
)
```

**Returns:** A callable net type constructor that creates typed net instances

### builtin.physical_value(unit)

**Built-in function** that creates unit-specific physical value constructor types for electrical quantities with optional tolerances.

```python
# Create physical value constructors for different units
Voltage = builtin.physical_value("V")
Current = builtin.physical_value("A")
Resistance = builtin.physical_value("Ohm")
Capacitance = builtin.physical_value("F")
Inductance = builtin.physical_value("H")
Frequency = builtin.physical_value("Hz")
Temperature = builtin.physical_value("K")
Time = builtin.physical_value("s")
Power = builtin.physical_value("W")

# Use the constructors to create physical values
supply = Voltage("3.3V")
current = Current("100mA")
resistor = Resistance("4k7")  # 4.7kΩ using resistor notation

# With tolerance
precise_voltage = Voltage("3.3V").with_tolerance("5%")  # 3.3V ±5%
loose_resistor = Resistance("10kOhm").with_tolerance(0.1)  # ±10%
```

**Parameters:**

- `unit`: String identifier for the physical unit (e.g., `"V"`, `"A"`, `"Ohm"`, `"F"`, `"H"`, `"Hz"`, `"K"`, `"s"`, `"W"`)

**Returns:** A `PhysicalValueType` that can be called to create `PhysicalValue` instances

**Standard Usage:**

This builtin is typically accessed through `@stdlib/units.zen`, which provides pre-defined constructors:

```python
load("@stdlib/units.zen", "Voltage", "Current", "Resistance", "unit")

# Create physical values
v = unit("3.3V", Voltage)
i = unit("100mA", Current)

# Perform calculations - units are tracked automatically
p = v * i  # Power = Voltage × Current (330mW)
r = v / i  # Resistance = Voltage / Current (33Ω)
```

**Physical Value Methods:**

Physical values support several methods for manipulation:

- `.with_tolerance(tolerance)` - Returns a new physical value with updated tolerance
  - `tolerance`: String like `"5%"` or decimal like `0.05`
- `.with_value(value)` - Returns a new physical value with updated numeric value
  - `value`: Numeric value (int or float)
- `.with_unit(unit)` - Returns a new physical value with updated unit (for unit conversion/casting)
  - `unit`: String unit identifier or `None` for dimensionless
- `.abs()` - Returns the absolute value of the physical value, preserving unit and tolerance
  - No parameters required
- `.diff(other)` - Returns the absolute difference between two physical values
  - `other`: Another PhysicalValue or string (e.g., `"5V"`) to compare against
  - Units must match or an error is raised
  - Always returns a positive value
  - Tolerance is dropped (consistent with subtraction behavior)
- `.within(other)` - Checks if this value's tolerance range fits completely within another's
  - `other`: Another PhysicalValue or string (e.g., `"3.3V"`)
  - Returns `True` if self's range is completely contained within other's range
  - Units must match or an error is raised

**Attributes:**

- `.value` - The numeric value as a float
- `.tolerance` - The tolerance as a decimal fraction (e.g., 0.05 for 5%)
- `.unit` - The unit string representation

**Mathematical Operations:**

Physical values support arithmetic with automatic unit tracking:

```python
# Multiplication - units multiply dimensionally
power = Voltage("3.3V") * Current("0.5A")  # 1.65W

# Division - units divide dimensionally
resistance = Voltage("5V") / Current("100mA")  # 50Ω

# Addition - requires matching units
total = Voltage("3.3V") + Voltage("5V")  # 8.3V

# Subtraction - requires matching units
delta = Voltage("5V") - Voltage("3.3V")  # 1.7V

# Absolute value
abs_voltage = Voltage("-3.3V").abs()  # 3.3V

# Difference (always positive)
diff = Voltage("3.3V").diff(Voltage("5V"))  # 1.7V
diff_str = Voltage("3.3V").diff("5V")       # 1.7V (strings are auto-converted)

# Tolerance validation
tight = Voltage("3.3V").with_tolerance("5%")   # 3.135V - 3.465V
loose = Voltage("3.3V").with_tolerance("10%")  # 2.97V - 3.63V
tight.within(loose)  # True - 5% tolerance fits within 10%
loose.within(tight)  # False - 10% doesn't fit within 5%
```

**Note:** All arithmetic operations and methods automatically convert string arguments to physical values when possible. For example, `Voltage("3.3V") + "2V"` works and returns `5.3V`.

**Tolerance Handling:**

- Multiplication/Division: Tolerance preserved only for dimensionless scaling (e.g., `2 * 3.3V±1%` keeps 1%)
- Addition/Subtraction: Tolerance is always dropped
- `.abs()`: Tolerance is preserved
- `.diff()`: Tolerance is dropped (consistent with subtraction)
- `.within()`: Considers tolerance ranges for both values

**Parsing Support:**

Physical value constructors accept flexible string formats:

```python
# Basic format with units
Voltage("3.3V")
Current("100mA")

# SI prefixes: m, μ/u, n, p, k, M, G
Capacitance("100nF")
Resistance("4.7kOhm")

# Resistor notation (4k7 = 4.7kΩ)
Resistance("4k7")

# Temperature conversions
Temperature("25C")   # Converts to Kelvin
Temperature("77F")   # Converts to Kelvin
```

### builtin.physical_range(unit)

**Built-in function** that creates unit-specific range constructor types for defining bounded physical value ranges.

```python
# Create range constructors for different units
VoltageRange = builtin.physical_range("V")
CurrentRange = builtin.physical_range("A")
ResistanceRange = builtin.physical_range("Ohm")
CapacitanceRange = builtin.physical_range("F")
InductanceRange = builtin.physical_range("H")
FrequencyRange = builtin.physical_range("Hz")
TemperatureRange = builtin.physical_range("K")
TimeRange = builtin.physical_range("s")
PowerRange = builtin.physical_range("W")

# Use the constructors to create ranges
input_voltage = VoltageRange("2.7V to 5.5V")
output_current = CurrentRange("0A to 3A")
operating_temp = TemperatureRange("-40C to 85C")

# All construction patterns are supported
supply = VoltageRange("11–26 V (12 V nom.)")           # String with nominal
tolerance = VoltageRange("15V 10%")                    # Tolerance expansion
explicit = VoltageRange(min=11, nominal=16, max=26)    # Keyword arguments
from_value = VoltageRange(Voltage(15))                 # From PhysicalValue
mixed = VoltageRange("11V to 26V", nominal="16V")      # Mixed modes
```

**Parameters:**

- `unit`: String identifier for the physical unit (e.g., `"V"`, `"A"`, `"Ohm"`, `"F"`, `"H"`, `"Hz"`, `"K"`, `"s"`, `"W"`)

**Returns:** A `PhysicalRangeType` that can be called to create `PhysicalRange` instances

**Standard Usage:**

This builtin is typically accessed through `@stdlib/units.zen`, which provides pre-defined range constructors:

```python
load("@stdlib/units.zen", "VoltageRange", "CurrentRange", "ResistanceRange")

# Use standard constructors from stdlib
input_range = VoltageRange("3.3V to 5V")
load_range = CurrentRange("100mA to 500mA")
pullup_range = ResistanceRange("4.7kOhm to 10kOhm")
```

**Available in stdlib/units.zen:**
- `VoltageRange` - Voltage ranges (V)
- `CurrentRange` - Current ranges (A)
- `ResistanceRange` - Resistance ranges (Ω)
- `CapacitanceRange` - Capacitance ranges (F)
- `InductanceRange` - Inductance ranges (H)
- `FrequencyRange` - Frequency ranges (Hz)
- `TemperatureRange` - Temperature ranges (K)
- `TimeRange` - Time ranges (s)
- `PowerRange` - Power ranges (W)

**Construction Patterns:**

The returned range constructor accepts flexible input formats:

```python
# String parsing with range separators
VoltageRange("1.1–3.6V")           # En-dash separator
VoltageRange("11V to 26V")         # Word "to" separator
VoltageRange("11–26V")             # Left side can omit unit

# Nominal value in parentheses
VoltageRange("11–26 V (12 V nom.)")

# Tolerance expansion
VoltageRange("15V 10%")            # Expands to 13.5–16.5 V

# From PhysicalValue
VoltageRange(Voltage(15))          # Single point: 15–15 V
VoltageRange(Voltage(15, 0.1))     # With tolerance: 13.5–16.5 V

# Keyword arguments (all must be present)
VoltageRange(min=11, max=26)
VoltageRange(min=11, nominal=16, max=26)

# Mixed string/number keywords
VoltageRange(min="11V", nominal="16", max="26V")

# Override nominal separately
VoltageRange("11V to 26V", nominal="16V")
```

**Type Safety:**

- Units must be consistent: `VoltageRange("5V to 3A")` → Error (mixing V and A)
- Range types are distinct: Cannot pass a `VoltageRange` where `CurrentRange` is expected
- Type checking enforces correctness at compile time

**Use Cases:**

Physical ranges are used to specify operating characteristics, constraints, and requirements:

```python
# Component specifications
input_voltage = VoltageRange("2.7V to 5.5V")
output_current = CurrentRange("0A to 3A (1.5A nom.)")
operating_temp = TemperatureRange("-40C to 85C")

# Load requirements
supply_current = CurrentRange("10mA to 100mA")
clock_frequency = FrequencyRange("1MHz to 100MHz")

# Tolerance specifications
capacitance = CapacitanceRange("100nF 10%")  # 90nF to 110nF
resistance = ResistanceRange("10kOhm 5%")    # 9.5kΩ to 10.5kΩ

# Future: Electrical Rule Checking (ERC)
# Validate that supply ranges satisfy load requirements
# check(supply_voltage_range.contains(load_voltage_range))
```

See [PhysicalRange](#physicalrange) in Core Types for detailed information about the returned range values.

### builtin.add_board_config(name, config, default=False)

**Built-in function** for registering board configurations with the layout system.

**Parameters:**
- `name`: String identifier for the board configuration
- `config`: `BoardConfig` object containing design rules and stackup
- `default`: If True, this becomes the default board config for the project

This builtin is typically called through the stdlib `Board()` function rather than directly.

### builtin.add_electrical_check(name, check_fn, inputs=None)

**Built-in function** for registering electrical validation checks that run during `pcb build`.

**Parameters:**
- `name`: String identifier for the check (required)
- `check_fn`: Function to execute for validation (required)
- `inputs`: Optional dictionary of input parameters to pass to the check function

Electrical checks use lazy evaluation - they are registered during module evaluation but execute after the design is fully evaluated. This allows checks to validate electrical properties, design rules, or other constraints across the entire design.

The check function receives the module as its first argument, followed by any specified inputs as keyword arguments:

```python
def voltage_range_check(module, min_voltage, max_voltage):
    """Check that supply voltage is within acceptable range"""
    supply = module.supply_voltage
    if supply < min_voltage or supply > max_voltage:
        error("Supply voltage {} is outside range {}-{}".format(
            supply, min_voltage, max_voltage
        ))

builtin.add_electrical_check(
    name="supply_voltage_range",
    check_fn=voltage_range_check,
    inputs={
        "min_voltage": 3.0,
        "max_voltage": 5.5,
    }
)
```

**Check Function Signature:**
```python
def check_function(module, **kwargs):
    # Validation logic
    # Raise error() or fail assertion to indicate failure
    pass
```

**Example - Basic Check:**
```python
def check_no_floating_nets(module):
    """Ensure all nets are connected to at least 2 pins"""
    for net in module.nets:
        if len(net.pins) < 2:
            error("Net '{}' is floating (only {} pin connected)".format(
                net.name, len(net.pins)
            ))

builtin.add_electrical_check(
    name="no_floating_nets",
    check_fn=check_no_floating_nets
)
```

**Example - Parameterized Check:**
```python
def check_power_capacity(module, max_current):
    """Verify power supply can handle load current"""
    total_load = sum([c.max_current for c in module.components])
    if total_load > max_current:
        error("Total load current {}A exceeds supply capacity {}A".format(
            total_load, max_current
        ))

builtin.add_electrical_check(
    name="power_capacity",
    check_fn=check_power_capacity,
    inputs={"max_current": 3.0}
)
```

**Execution Model:**

1. Checks are registered during module evaluation via `builtin.add_electrical_check()`
2. Check functions and inputs are stored as frozen values
3. During `pcb build`, after evaluation completes, all checks are collected from the module tree
4. Each check executes with a fresh evaluator context
5. Check failures generate error diagnostics that are reported through the standard diagnostic system
6. Build fails if any electrical checks fail

**Notes:**
- Checks run only during `pcb build`, not during `pcb test` (use `TestBench` for test-specific validation)
- Check failures generate error-level diagnostics
- Checks can access the entire module structure, including components, nets, interfaces, and properties
- Multiple checks with the same name are allowed (they execute independently)

### builtin.add_component_modifier(modifier_fn)

**Built-in function** for registering component modifier functions that automatically run on every component created in the current module and all descendant modules.

**Parameters:**
- `modifier_fn`: Function that accepts a component and modifies it (required)

Component modifiers enable organization-wide policies by allowing parent modules to automatically modify components created in child modules. Modifiers execute in **bottom-up order**: child's own modifiers first, then parent's, then grandparent's. This allows parent policies to override child choices.

**Modifier Function Signature:**
```python
def modifier_function(component):
    # Modify component properties
    # No return value required
    pass
```

**Example - Assign Part Numbers for Generic Components:**
```python
def assign_parts(component):
    """Convert generic components to specific part numbers"""
    # Resistors
    if hasattr(component, "resistance"):
        if component.resistance == "10k":
            component.manufacturer = "Yageo"
            component.mpn = "RC0603FR-0710KL"

    # Capacitors
    if hasattr(component, "capacitance"):
        if component.capacitance == "10uF":
            component.manufacturer = "Samsung"
            component.mpn = "CL21A106KAYNNNE"

builtin.add_component_modifier(assign_parts)

# Child modules use generic components, parent assigns real parts
ChildBoard = Module("Child.zen")
ChildBoard(name="Board1")
```

**Execution Model:**

1. Modifiers are registered during module evaluation via `builtin.add_component_modifier()`
2. When a child module is instantiated, it inherits all ancestor modifiers
3. Each component creation triggers modifiers in bottom-up order:
   - Module's own modifiers execute first
   - Parent's modifiers execute next
   - Grandparent's and further ancestors follow
4. Modifiers can read and write any component property (mpn, manufacturer, dnp, custom properties)

**Notes:**
- Modifiers only apply to components created AFTER registration
- Parent modifiers run AFTER child modifiers (can override child choices)
- Modifiers are inherited through the entire module hierarchy
- Common uses: vendor policies, DNP rules, property validation, debug tagging

### builtin.current_module_path()

**Built-in function** that returns the current module's path as a list of strings.

**Returns:** List of strings representing the module hierarchy
- Root module: `[]` (empty list)
- Child module: `["child_name"]`
- Nested module: `["parent_name", "child_name"]`

This function enables conditional logic based on module depth or position in the hierarchy. Common use case: applying different policies at the root module versus child modules.

**Example - Conditional BOM Modifiers at Root:**
```python
# Apply BOM modifiers only at the root module
def bom_modifier(component):
    component.bom_notes = "Production-ready"

if len(builtin.current_module_path()) == 0:
    builtin.add_component_modifier(bom_modifier)
```

**Example - Check Module Depth:**
```python
path = builtin.current_module_path()
if len(path) > 2:
    print("Warning: deeply nested module")
```

See the [Testing](/pages/testing) documentation for TestBench and circuit graph analysis.
