#!/usr/bin/env python3
import argparse
import json
import os
import subprocess
import sys
import tempfile


def run_json(cmd: list[str], cwd: str | None) -> dict:
    result = subprocess.run(
        cmd,
        cwd=cwd,
        check=True,
        text=True,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
    )
    try:
        return json.loads(result.stdout)
    except json.JSONDecodeError as exc:
        raise RuntimeError(
            f"Failed to parse JSON from {' '.join(cmd)}: {exc}\n{result.stdout}"
        ) from exc


def run_hyperfine(cmd: list[str], cwd: str, warmup: int) -> dict:
    """Run hyperfine and return its results."""
    with tempfile.NamedTemporaryFile(suffix=".json", delete=False) as f:
        tmp_path = f.name
    try:
        # With --shell=none, hyperfine expects the command as a single string
        cmd_str = " ".join(cmd)
        subprocess.run(
            [
                "hyperfine",
                "--warmup", str(warmup),
                "--export-json", tmp_path,
                "--shell=none",
                cmd_str,
            ],
            cwd=cwd,
            check=True,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
        )
        with open(tmp_path) as f:
            data = json.load(f)
        return data["results"][0]
    finally:
        os.unlink(tmp_path)


def normalize_rel_path(rel_path: object) -> str:
    if rel_path is None:
        return ""
    if isinstance(rel_path, list):
        return "/".join(str(part) for part in rel_path)
    return str(rel_path)


def collect_boards(workspace_info: dict) -> list[dict]:
    boards: list[dict] = []
    packages = workspace_info.get("packages", {})
    for pkg in packages.values():
        config = pkg.get("config") or {}
        board = config.get("board")
        if not board:
            continue
        zen_path = board.get("path")
        if not zen_path:
            continue
        rel_path = normalize_rel_path(pkg.get("rel_path"))
        if rel_path:
            zen_rel = os.path.join(rel_path, zen_path)
        else:
            zen_rel = zen_path
        boards.append(
            {
                "name": board.get("name") or zen_rel,
                "zen_path": zen_rel,
            }
        )
    boards.sort(key=lambda b: b["zen_path"])
    return boards


def main() -> int:
    parser = argparse.ArgumentParser(
        description="Measure pcb build performance across boards in a workspace."
    )
    parser.add_argument(
        "--workspace",
        required=True,
        help="Path to workspace root (contains pcb.toml).",
    )
    parser.add_argument(
        "--pcb",
        default="pcb",
        help="Path to pcb binary (default: pcb in PATH).",
    )
    parser.add_argument(
        "--output",
        help="Write JSON output to this path (also prints to stdout).",
    )
    parser.add_argument(
        "--locked",
        action="store_true",
        help="Pass --locked to pcb build.",
    )
    parser.add_argument(
        "--offline",
        action="store_true",
        help="Pass --offline to pcb build.",
    )
    parser.add_argument(
        "--warmup",
        type=int,
        default=3,
        help="Warmup runs per board (default: 3).",
    )
    args = parser.parse_args()

    workspace = os.path.abspath(args.workspace)
    if not os.path.isdir(workspace):
        raise SystemExit(f"Workspace directory not found: {workspace}")

    pcb_path = os.path.abspath(args.pcb) if not args.pcb.startswith("/") and args.pcb != "pcb" else args.pcb

    info = run_json([pcb_path, "info", "-f", "json", workspace], cwd=None)
    boards = collect_boards(info)
    if not boards:
        raise SystemExit(f"No boards found in workspace: {workspace}")

    build_flags: list[str] = []
    if args.locked:
        build_flags.append("--locked")
    if args.offline:
        build_flags.append("--offline")

    if args.warmup < 0:
        raise SystemExit("--warmup must be >= 0")

    board_results = []
    for board in boards:
        zen_path = board["zen_path"]
        cmd = [pcb_path, "build", *build_flags, zen_path]

        hf = run_hyperfine(cmd, cwd=workspace, warmup=args.warmup)

        board_results.append(
            {
                "name": board["name"],
                "zen_path": zen_path,
                # Hyperfine metrics (all times in seconds)
                "mean_seconds": hf["mean"],
                "stddev_seconds": hf["stddev"],
                "median_seconds": hf["median"],
                "min_seconds": hf["min"],
                "max_seconds": hf["max"],
                "user_seconds": hf["user"],
                "system_seconds": hf["system"],
                "runs": hf["times"],
                "n": len(hf["times"]),
            }
        )

    output = {
        "workspace": workspace,
        "board_count": len(board_results),
        "boards": board_results,
        "warmup_runs": args.warmup,
    }

    payload = json.dumps(output, indent=2, sort_keys=True)
    print(payload)
    if args.output:
        with open(args.output, "w", encoding="utf-8") as handle:
            handle.write(payload)
            handle.write("\n")
    return 0


if __name__ == "__main__":
    sys.exit(main())
