#!/usr/bin/env python3
import argparse
import json
import math
import os
import statistics
import subprocess
import sys
import time


T_CRITICAL_95 = {
    1: 12.706,
    2: 4.303,
    3: 3.182,
    4: 2.776,
    5: 2.571,
    6: 2.447,
    7: 2.365,
    8: 2.306,
    9: 2.262,
    10: 2.228,
    11: 2.201,
    12: 2.179,
    13: 2.160,
    14: 2.145,
    15: 2.131,
    16: 2.120,
    17: 2.110,
    18: 2.101,
    19: 2.093,
    20: 2.086,
    21: 2.080,
    22: 2.074,
    23: 2.069,
    24: 2.064,
    25: 2.060,
    26: 2.056,
    27: 2.052,
    28: 2.048,
    29: 2.045,
    30: 2.042,
}


def t_critical_95(df: int) -> float:
    if df <= 0:
        return 0.0
    return T_CRITICAL_95.get(df, 1.96)


def run_json(cmd: list[str], cwd: str | None) -> dict:
    result = subprocess.run(
        cmd,
        cwd=cwd,
        check=True,
        text=True,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
    )
    try:
        return json.loads(result.stdout)
    except json.JSONDecodeError as exc:
        raise RuntimeError(
            f"Failed to parse JSON from {' '.join(cmd)}: {exc}\n{result.stdout}"
        ) from exc


def run_timed(cmd: list[str], cwd: str | None) -> float:
    start = time.perf_counter()
    subprocess.run(
        cmd,
        cwd=cwd,
        check=True,
        stdout=subprocess.DEVNULL,
        stderr=subprocess.DEVNULL,
    )
    end = time.perf_counter()
    return end - start


def normalize_rel_path(rel_path: object) -> str:
    if rel_path is None:
        return ""
    if isinstance(rel_path, list):
        return "/".join(str(part) for part in rel_path)
    return str(rel_path)


def collect_boards(workspace_info: dict) -> list[dict]:
    boards: list[dict] = []
    packages = workspace_info.get("packages", {})
    for pkg in packages.values():
        config = pkg.get("config") or {}
        board = config.get("board")
        if not board:
            continue
        zen_path = board.get("path")
        if not zen_path:
            continue
        rel_path = normalize_rel_path(pkg.get("rel_path"))
        if rel_path:
            zen_rel = os.path.join(rel_path, zen_path)
        else:
            zen_rel = zen_path
        boards.append(
            {
                "name": board.get("name") or zen_rel,
                "zen_path": zen_rel,
            }
        )
    boards.sort(key=lambda b: b["zen_path"])
    return boards


def summarize_runtimes(runtimes: list[float]) -> dict:
    n = len(runtimes)
    mean = statistics.mean(runtimes) if runtimes else 0.0
    if n >= 2:
        stdev = statistics.stdev(runtimes)
        se = stdev / math.sqrt(n)
        t_value = t_critical_95(n - 1)
        margin = t_value * se
    else:
        stdev = 0.0
        se = 0.0
        t_value = 0.0
        margin = 0.0
    return {
        "n": n,
        "mean_seconds": mean,
        "stdev_seconds": stdev,
        "se_seconds": se,
        "t_critical_95": t_value,
        "ci95_low_seconds": mean - margin,
        "ci95_high_seconds": mean + margin,
    }


def main() -> int:
    parser = argparse.ArgumentParser(
        description="Measure pcb build performance across boards in a workspace."
    )
    parser.add_argument(
        "--workspace",
        required=True,
        help="Path to workspace root (contains pcb.toml).",
    )
    parser.add_argument(
        "--pcb",
        default="pcb",
        help="Path to pcb binary (default: pcb in PATH).",
    )
    parser.add_argument(
        "--output",
        help="Write JSON output to this path (also prints to stdout).",
    )
    parser.add_argument(
        "--locked",
        action="store_true",
        help="Pass --locked to pcb build.",
    )
    parser.add_argument(
        "--offline",
        action="store_true",
        help="Pass --offline to pcb build.",
    )
    parser.add_argument(
        "--warmup",
        type=int,
        default=2,
        help="Warmup runs per board (default: 2).",
    )
    parser.add_argument(
        "--runs",
        type=int,
        default=5,
        help="Measured runs per board (default: 5).",
    )
    args = parser.parse_args()

    workspace = os.path.abspath(args.workspace)
    if not os.path.isdir(workspace):
        raise SystemExit(f"Workspace directory not found: {workspace}")

    pcb_path = args.pcb

    info = run_json([pcb_path, "info", "-f", "json", workspace], cwd=None)
    boards = collect_boards(info)
    if not boards:
        raise SystemExit(f"No boards found in workspace: {workspace}")

    build_flags: list[str] = []
    if args.locked:
        build_flags.append("--locked")
    if args.offline:
        build_flags.append("--offline")

    if args.warmup < 0 or args.runs < 1:
        raise SystemExit("--warmup must be >= 0 and --runs must be >= 1")

    board_runs = []
    for board in boards:
        zen_path = board["zen_path"]
        for _ in range(args.warmup):
            run_timed([pcb_path, "build", *build_flags, zen_path], cwd=workspace)

        runtimes = []
        for _ in range(args.runs):
            duration = run_timed([pcb_path, "build", *build_flags, zen_path], cwd=workspace)
            runtimes.append(duration)

        stats = summarize_runtimes(runtimes)
        board_runs.append(
            {
                "name": board["name"],
                "zen_path": zen_path,
                "runs": runtimes,
                **stats,
            }
        )

    output = {
        "workspace": workspace,
        "board_count": len(board_runs),
        "boards": board_runs,
        "warmup_runs": args.warmup,
        "measured_runs": args.runs,
    }

    payload = json.dumps(output, indent=2, sort_keys=True)
    print(payload)
    if args.output:
        with open(args.output, "w", encoding="utf-8") as handle:
            handle.write(payload)
            handle.write("\n")
    return 0


if __name__ == "__main__":
    sys.exit(main())
